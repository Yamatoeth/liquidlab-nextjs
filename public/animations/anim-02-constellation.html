<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Constellation Field — FORMA</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #02020a; overflow: hidden; width: 100vw; height: 100vh; }
  canvas { display: block; }
  .label {
    position: fixed; bottom: 24px; left: 24px;
    font-family: 'Courier New', monospace;
    font-size: 11px; letter-spacing: 0.15em;
    color: rgba(255,255,255,0.2);
    text-transform: uppercase;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="label">Constellation Field · Move cursor</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
const mouse = { x: -9999, y: -9999 };
const CONNECT_DIST = 120;
const MOUSE_DIST = 180;
const N = 120;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', () => { resize(); initParticles(); });
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('touchmove', e => { mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; }, { passive: true });
window.addEventListener('mouseleave', () => { mouse.x = -9999; mouse.y = -9999; });

let particles = [];

function initParticles() {
  particles = Array.from({ length: N }, () => ({
    x: Math.random() * W,
    y: Math.random() * H,
    vx: (Math.random() - 0.5) * 0.4,
    vy: (Math.random() - 0.5) * 0.4,
    r: Math.random() * 1.5 + 0.5,
    hue: Math.random() * 60 + 200, // blue-purple range
  }));
}
initParticles();

// Mouse repel particles
function mousePush() {
  particles.forEach(p => {
    const dx = p.x - mouse.x;
    const dy = p.y - mouse.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < MOUSE_DIST && dist > 0) {
      const force = (MOUSE_DIST - dist) / MOUSE_DIST * 0.8;
      p.vx += (dx / dist) * force;
      p.vy += (dy / dist) * force;
    }
  });
}

// Extra cursor particles
let cursorTrail = [];

function draw() {
  ctx.fillStyle = 'rgba(2,2,10,0.2)';
  ctx.fillRect(0, 0, W, H);

  mousePush();

  // Update
  particles.forEach(p => {
    p.vx *= 0.98;
    p.vy *= 0.98;
    p.x += p.vx;
    p.y += p.vy;
    if (p.x < 0) p.x = W;
    if (p.x > W) p.x = 0;
    if (p.y < 0) p.y = H;
    if (p.y > H) p.y = 0;
  });

  // Draw connections
  for (let i = 0; i < N; i++) {
    for (let j = i + 1; j < N; j++) {
      const dx = particles[i].x - particles[j].x;
      const dy = particles[i].y - particles[j].y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < CONNECT_DIST) {
        const alpha = (1 - dist / CONNECT_DIST) * 0.5;
        ctx.beginPath();
        ctx.strokeStyle = `rgba(150,160,255,${alpha})`;
        ctx.lineWidth = (1 - dist / CONNECT_DIST) * 1.2;
        ctx.moveTo(particles[i].x, particles[i].y);
        ctx.lineTo(particles[j].x, particles[j].y);
        ctx.stroke();
      }
    }
  }

  // Mouse connections
  particles.forEach(p => {
    const dx = p.x - mouse.x;
    const dy = p.y - mouse.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < MOUSE_DIST) {
      const alpha = (1 - dist / MOUSE_DIST) * 0.8;
      ctx.beginPath();
      ctx.strokeStyle = `rgba(200,180,255,${alpha})`;
      ctx.lineWidth = (1 - dist / MOUSE_DIST) * 1.5;
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(mouse.x, mouse.y);
      ctx.stroke();
    }
  });

  // Draw dots
  particles.forEach(p => {
    const dx = p.x - mouse.x;
    const dy = p.y - mouse.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const glow = dist < MOUSE_DIST ? (1 - dist / MOUSE_DIST) : 0;
    const r = p.r + glow * 2;

    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${p.hue}, 80%, ${70 + glow * 30}%, ${0.6 + glow * 0.4})`;
    ctx.fill();

    if (glow > 0.3) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, r * 3, 0, Math.PI * 2);
      const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 3);
      grad.addColorStop(0, `hsla(${p.hue}, 100%, 80%, ${glow * 0.3})`);
      grad.addColorStop(1, `hsla(${p.hue}, 100%, 80%, 0)`);
      ctx.fillStyle = grad;
      ctx.fill();
    }
  });

  // Mouse dot
  if (mouse.x > 0) {
    ctx.beginPath();
    ctx.arc(mouse.x, mouse.y, 3, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(200,180,255,0.8)';
    ctx.fill();
    const grad = ctx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, 30);
    grad.addColorStop(0, 'rgba(200,180,255,0.15)');
    grad.addColorStop(1, 'rgba(200,180,255,0)');
    ctx.beginPath();
    ctx.arc(mouse.x, mouse.y, 30, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
  }

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
