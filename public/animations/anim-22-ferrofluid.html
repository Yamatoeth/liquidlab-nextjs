<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ferrofluid — FORMA</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300&family=DM+Mono:wght@300&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    width: 100vw; height: 100vh;
    overflow: hidden;
    cursor: none;
  }

  canvas { position: fixed; inset: 0; }
  #glowCanvas { z-index: 1; }
  #mainCanvas { z-index: 2; }
  #uiCanvas   { z-index: 3; pointer-events: none; }

  .ui {
    position: fixed; inset: 0;
    pointer-events: none;
    z-index: 10;
  }

  .title {
    position: absolute;
    bottom: 44px; left: 50%;
    transform: translateX(-50%);
    text-align: center;
    letter-spacing: 0.35em;
  }
  .title-main {
    font-family: 'Cormorant Garamond', serif;
    font-size: clamp(11px, 1.4vw, 15px);
    font-weight: 300;
    color: rgba(255,255,255,0.2);
    text-transform: uppercase;
  }
  .title-sub {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    color: rgba(255,255,255,0.1);
    letter-spacing: 0.4em;
    margin-top: 6px;
    text-transform: uppercase;
  }

  .corner {
    position: absolute;
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    color: rgba(255,255,255,0.12);
    letter-spacing: 0.2em;
    text-transform: uppercase;
    line-height: 1.9;
  }
  .corner-tl { top: 28px; left: 32px; }
  .corner-tr { top: 28px; right: 32px; text-align: right; }
  .corner-br { bottom: 28px; right: 32px; text-align: right; }

  /* Crosshair cursor */
  #cursor {
    position: fixed; pointer-events: none; z-index: 100;
    transform: translate(-50%, -50%);
  }
  #cursor svg { width: 24px; height: 24px; }
</style>
</head>
<body>

<canvas id="glowCanvas"></canvas>
<canvas id="mainCanvas"></canvas>

<div class="ui">
  <div class="corner corner-tl">
    Ferrofluid · v1.0<br>
    <span id="peakCount">0</span> spikes active
  </div>
  <div class="corner corner-tr">
    ∇B = <span id="fieldVal">0.00</span> T/m<br>
    μ₀ = 4π × 10⁻⁷
  </div>
  <div class="corner corner-br">
    Move cursor · Click to repel
  </div>

  <div class="title">
    <div class="title-main">Ferrofluid Simulation</div>
    <div class="title-sub">Magnetic field · Surface tension · Rosensweig effect</div>
  </div>
</div>

<div id="cursor">
  <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <circle cx="12" cy="12" r="4" stroke="rgba(255,255,255,0.6)" stroke-width="0.8"/>
    <line x1="12" y1="2" x2="12" y2="7" stroke="rgba(255,255,255,0.4)" stroke-width="0.8"/>
    <line x1="12" y1="17" x2="12" y2="22" stroke="rgba(255,255,255,0.4)" stroke-width="0.8"/>
    <line x1="2" y1="12" x2="7" y2="12" stroke="rgba(255,255,255,0.4)" stroke-width="0.8"/>
    <line x1="17" y1="12" x2="22" y2="12" stroke="rgba(255,255,255,0.4)" stroke-width="0.8"/>
  </svg>
</div>

<script>
// ── SETUP ───────────────────────────────────────────────────────────────────────
const glowC  = document.getElementById('glowCanvas');
const mainC  = document.getElementById('mainCanvas');
const glowCtx = glowC.getContext('2d');
const ctx     = mainC.getContext('2d');
const cursorEl = document.getElementById('cursor');

let W, H, cx, cy;
function resize() {
  W = glowC.width  = mainC.width  = window.innerWidth;
  H = glowC.height = mainC.height = window.innerHeight;
  cx = W / 2; cy = H / 2;
}
resize();
window.addEventListener('resize', resize);

// ── MOUSE ───────────────────────────────────────────────────────────────────────
const mouse = { x: cx, y: cy, sx: cx, sy: cy, down: false, vx: 0, vy: 0, px: cx, py: cy };

window.addEventListener('mousemove', e => {
  mouse.px = mouse.x; mouse.py = mouse.y;
  mouse.x = e.clientX; mouse.y = e.clientY;
  mouse.vx = mouse.x - mouse.px;
  mouse.vy = mouse.y - mouse.py;
  cursorEl.style.left = e.clientX + 'px';
  cursorEl.style.top  = e.clientY + 'px';
});
window.addEventListener('mousedown', () => mouse.down = true);
window.addEventListener('mouseup',   () => mouse.down = false);
window.addEventListener('touchmove', e => {
  mouse.px = mouse.x; mouse.py = mouse.y;
  mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY;
  mouse.vx = mouse.x - mouse.px; mouse.vy = mouse.y - mouse.py;
  cursorEl.style.left = mouse.x + 'px'; cursorEl.style.top = mouse.y + 'px';
}, { passive: true });
window.addEventListener('touchstart', e => { mouse.down = true; mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; }, { passive: true });
window.addEventListener('touchend', () => mouse.down = false);

// ── MATH UTILS ──────────────────────────────────────────────────────────────────
const lerp  = (a,b,t) => a + (b-a)*t;
const clamp = (v,mn,mx) => Math.max(mn,Math.min(mx,v));
const dist  = (ax,ay,bx,by) => Math.hypot(ax-bx, ay-by);
const smoothstep = (e0,e1,x) => { const t=clamp((x-e0)/(e1-e0),0,1); return t*t*(3-2*t); };

// ── FLUID SURFACE ───────────────────────────────────────────────────────────────
// We model the ferrofluid as a ring of particles forming a closed surface
// with a "height field" that spikes toward the magnetic source (mouse)

const NUM_SURFACE = 260;      // points around the perimeter
const BASE_RADIUS  = () => Math.min(W, H) * 0.28;
const MAX_SPIKE    = () => Math.min(W, H) * 0.22;

class SurfacePoint {
  constructor(index, total) {
    this.index   = index;
    this.angle   = (index / total) * Math.PI * 2;
    this.r       = 0;   // radial offset from base
    this.vr      = 0;   // radial velocity
    this.tension = 0.018;
    this.damping = 0.89;
  }
}

const surface = Array.from({ length: NUM_SURFACE }, (_, i) => new SurfacePoint(i, NUM_SURFACE));

// Magnetic field sources (permanent magnets + mouse)
const MAGNETS = [
  { angle: 0,               strength: 0.4, orbit: 0.0 },
  { angle: Math.PI*2/3,     strength: 0.3, orbit: 0.0 },
  { angle: Math.PI*4/3,     strength: 0.35,orbit: 0.0 },
];

// Spike peaks — track each rosensweig peak
const peaks = [];
let peakTimer = 0;

function spawnPeak(angle) {
  // avoid duplicate peaks too close
  for (const p of peaks) {
    const diff = Math.abs(p.angle - angle);
    const wrap = Math.min(diff, Math.PI*2-diff);
    if (wrap < 0.25) return;
  }
  peaks.push({ angle, target: 0.6 + Math.random()*0.4, cur: 0, life: 1, speed: 0.015+Math.random()*0.01 });
}

// ── DROPLETS (detached spheres flying off) ───────────────────────────────────
const droplets = [];
class Droplet {
  constructor(x, y, vx, vy) {
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.r = 2 + Math.random() * 5;
    this.life = 1;
    this.decay = 0.008 + Math.random() * 0.012;
    this.trail = [];
  }
  update() {
    this.trail.push({ x: this.x, y: this.y });
    if (this.trail.length > 14) this.trail.shift();
    this.vx *= 0.97; this.vy = this.vy * 0.97 + 0.08;
    this.x += this.vx; this.y += this.vy;
    this.life -= this.decay;
  }
}

// ── RENDER HELPERS ──────────────────────────────────────────────────────────────

// Convert surface points to world XY
function surfaceXY(s) {
  const br = BASE_RADIUS();
  const r  = br + s.r;
  return { x: cx + Math.cos(s.angle)*r, y: cy + Math.sin(s.angle)*r };
}

// Draw the ferrofluid blob with metaball-smooth contour
function buildBlobPath() {
  const pts = surface.map(surfaceXY);
  const n   = pts.length;
  ctx.beginPath();
  for (let i = 0; i < n; i++) {
    const p0 = pts[(i-1+n)%n];
    const p1 = pts[i];
    const p2 = pts[(i+1)%n];
    const p3 = pts[(i+2)%n];
    const cp1x = p1.x + (p2.x - p0.x) / 6;
    const cp1y = p1.y + (p2.y - p0.y) / 6;
    const cp2x = p2.x - (p3.x - p1.x) / 6;
    const cp2y = p2.y - (p3.y - p1.y) / 6;
    if (i === 0) ctx.moveTo(p1.x, p1.y);
    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
  }
  ctx.closePath();
}

// ── PHYSICS UPDATE ──────────────────────────────────────────────────────────────
let time = 0;
let fieldMagnitude = 0;

function physicsStep() {
  time += 0.016;
  const br  = BASE_RADIUS();
  const msp = MAX_SPIKE();
  const mVel = Math.hypot(mouse.vx, mouse.vy);

  // Smooth mouse
  mouse.sx = lerp(mouse.sx, mouse.x, 0.06);
  mouse.sy = lerp(mouse.sy, mouse.y, 0.06);

  // Mouse attraction / repulsion
  const mdx   = mouse.sx - cx;
  const mdy   = mouse.sy - cy;
  const mDist = Math.hypot(mdx, mdy);
  const mAngle = Math.atan2(mdy, mdx);
  const mNorm  = clamp(1 - mDist / (Math.min(W,H)*0.6), 0, 1);
  fieldMagnitude = mNorm * 3 + 0.2*Math.sin(time*0.8);

  // Permanent magnet orbit
  MAGNETS.forEach((mag, mi) => {
    mag.orbit += 0.0008 + mi * 0.0003;
  });

  // Update each surface point
  surface.forEach((s, si) => {
    const angle = s.angle;

    // ── Tension force (pulls toward base radius)
    const tensionForce = -s.r * s.tension;

    // ── Magnetic force from mouse (Rosensweig instability)
    const angDiff  = Math.atan2(Math.sin(angle - mAngle), Math.cos(angle - mAngle));
    const angClose = 1 - Math.abs(angDiff) / Math.PI;
    const mouseMag = mNorm * msp * 0.12 * Math.pow(angClose, 2.2);
    const repel    = mouse.down ? -mouseMag * 2.5 : mouseMag;

    // ── Permanent magnet forces
    let magForce = 0;
    MAGNETS.forEach(mag => {
      const magAngle = mag.orbit;
      const diff = Math.atan2(Math.sin(angle - magAngle), Math.cos(angle - magAngle));
      const close = 1 - Math.abs(diff) / Math.PI;
      magForce += mag.strength * msp * 0.04 * Math.pow(close, 3);
    });

    // ── Neighbor tension (surface smoothing)
    const prev = surface[(si - 1 + NUM_SURFACE) % NUM_SURFACE];
    const next = surface[(si + 1) % NUM_SURFACE];
    const neighborForce = (prev.r + next.r - 2 * s.r) * 0.12;

    // ── Noise ripple (Brownian magnetic fluctuation)
    const noiseForce = Math.sin(angle * 7 + time * 1.8) * 0.3
                     + Math.sin(angle * 13 - time * 2.4) * 0.15
                     + Math.sin(angle * 3  + time * 0.9) * 0.5;

    // Integrate
    const totalForce = tensionForce + repel + magForce + neighborForce + noiseForce;
    s.vr = (s.vr + totalForce) * s.damping;
    s.r  = clamp(s.r + s.vr, -br * 0.15, msp);
  });

  // Spawn peaks at strong magnetic zones
  peakTimer++;
  if (peakTimer % 8 === 0 && mNorm > 0.2) {
    spawnPeak(mAngle + (Math.random()-0.5)*0.4);
  }
  MAGNETS.forEach(mag => {
    if (peakTimer % 22 === 0) spawnPeak(mag.orbit + (Math.random()-0.5)*0.3);
  });

  // Update peaks
  for (let i = peaks.length-1; i >= 0; i--) {
    const p = peaks[i];
    p.cur = lerp(p.cur, p.target, p.speed);
    p.life -= 0.003;
    if (p.life < 0) peaks.splice(i, 1);
  }

  // Spawn droplets from high spikes (fast cursor)
  if (mVel > 18) {
    const sp = surface[Math.round((mAngle / (Math.PI*2) + 1) * NUM_SURFACE / 2) % NUM_SURFACE];
    if (sp.r > msp * 0.7) {
      const ejectPt = surfaceXY(sp);
      droplets.push(new Droplet(
        ejectPt.x, ejectPt.y,
        Math.cos(sp.angle) * mVel * 0.3 + (Math.random()-0.5)*2,
        Math.sin(sp.angle) * mVel * 0.3 - Math.random()*2
      ));
    }
  }

  // Update droplets
  for (let i = droplets.length-1; i >= 0; i--) {
    droplets[i].update();
    if (droplets[i].life <= 0) droplets.splice(i, 1);
  }
}

// ── RENDERING ───────────────────────────────────────────────────────────────────
function render() {
  // ── GLOW LAYER ──
  glowCtx.clearRect(0, 0, W, H);

  // Ambient under-glow
  const ambR = BASE_RADIUS() * 1.4;
  const amb  = glowCtx.createRadialGradient(cx, cy, 0, cx, cy, ambR);
  amb.addColorStop(0,   'rgba(30,20,10,0.6)');
  amb.addColorStop(0.5, 'rgba(20,12,5,0.3)');
  amb.addColorStop(1,   'rgba(0,0,0,0)');
  glowCtx.fillStyle = amb;
  glowCtx.beginPath(); glowCtx.arc(cx, cy, ambR, 0, Math.PI*2); glowCtx.fill();

  // Glow where spikes are high
  surface.forEach((s, si) => {
    if (s.r < MAX_SPIKE() * 0.3) return;
    const pt  = surfaceXY(s);
    const t   = s.r / MAX_SPIKE();
    const gr  = glowCtx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, 40*t);
    gr.addColorStop(0, `rgba(255,${Math.floor(160-t*100)},${Math.floor(60-t*40)},${t*0.2})`);
    gr.addColorStop(1, 'rgba(0,0,0,0)');
    glowCtx.fillStyle = gr;
    glowCtx.beginPath(); glowCtx.arc(pt.x, pt.y, 40*t, 0, Math.PI*2); glowCtx.fill();
  });

  // ── MAIN LAYER ──
  ctx.clearRect(0, 0, W, H);

  // Background
  const bg = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(W,H)*0.7);
  bg.addColorStop(0,   '#0a0702');
  bg.addColorStop(0.5, '#060503');
  bg.addColorStop(1,   '#020202');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  // ── DROPLET TRAILS ──
  droplets.forEach(d => {
    d.trail.forEach((t, ti) => {
      const a = (ti/d.trail.length)*d.life*0.4;
      ctx.beginPath(); ctx.arc(t.x, t.y, d.r*(ti/d.trail.length)*0.6, 0, Math.PI*2);
      ctx.fillStyle = `rgba(20,14,6,${a})`; ctx.fill();
    });
  });

  // ── FLUID BODY ──
  buildBlobPath();

  // Multi-layer fill for depth & iridescence
  // 1. Deep base
  const bodyFill = ctx.createRadialGradient(cx - BASE_RADIUS()*0.3, cy - BASE_RADIUS()*0.2, 0, cx, cy, BASE_RADIUS()*1.5);
  bodyFill.addColorStop(0,   '#1a1208');
  bodyFill.addColorStop(0.35,'#110e06');
  bodyFill.addColorStop(0.7, '#0a0804');
  bodyFill.addColorStop(1,   '#050402');
  ctx.fillStyle = bodyFill;
  ctx.fill();

  // 2. Iridescent sheen — color shifts with time
  buildBlobPath();
  const iridescentAngle = time * 0.3;
  const irX = cx + Math.cos(iridescentAngle) * BASE_RADIUS() * 0.5;
  const irY = cy + Math.sin(iridescentAngle) * BASE_RADIUS() * 0.3;
  const irid = ctx.createRadialGradient(irX, irY, 0, cx, cy, BASE_RADIUS()*1.2);
  const hue1 = (time * 15) % 360;
  const hue2 = (hue1 + 60) % 360;
  irid.addColorStop(0,   `hsla(${hue1},60%,30%,0.07)`);
  irid.addColorStop(0.4, `hsla(${hue2},50%,20%,0.04)`);
  irid.addColorStop(1,   'rgba(0,0,0,0)');
  ctx.fillStyle = irid;
  ctx.fill();

  // 3. Specular highlight — top-left
  buildBlobPath();
  const spec = ctx.createRadialGradient(
    cx - BASE_RADIUS()*0.45, cy - BASE_RADIUS()*0.35, 0,
    cx - BASE_RADIUS()*0.3,  cy - BASE_RADIUS()*0.2,  BASE_RADIUS()*0.9
  );
  spec.addColorStop(0,   'rgba(255,220,140,0.09)');
  spec.addColorStop(0.3, 'rgba(255,200,100,0.04)');
  spec.addColorStop(1,   'rgba(0,0,0,0)');
  ctx.fillStyle = spec;
  ctx.fill();

  // ── FLUID EDGE (stroke) ──
  buildBlobPath();
  ctx.shadowBlur  = 0;
  ctx.strokeStyle = 'rgba(80,60,20,0.5)';
  ctx.lineWidth   = 1.5;
  ctx.stroke();

  // Bright edge highlight
  buildBlobPath();
  const edgeGrad = ctx.createLinearGradient(cx-BASE_RADIUS(), cy-BASE_RADIUS(), cx+BASE_RADIUS(), cy+BASE_RADIUS());
  edgeGrad.addColorStop(0,   'rgba(220,180,80,0.25)');
  edgeGrad.addColorStop(0.5, 'rgba(180,140,50,0.08)');
  edgeGrad.addColorStop(1,   'rgba(100,80,20,0.2)');
  ctx.strokeStyle = edgeGrad;
  ctx.lineWidth   = 0.8;
  ctx.stroke();

  // ── SPIKE TIPS (Rosensweig peaks) ──
  // Highlight the tallest spike tips with a micro specular dot
  surface.forEach((s, si) => {
    const t = s.r / MAX_SPIKE();
    if (t < 0.4) return;
    const pt = surfaceXY(s);

    // Tip glow
    const tg = ctx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, 8*t);
    tg.addColorStop(0,   `rgba(255,${Math.floor(200*t+55)},${Math.floor(80*t)},${t*0.5})`);
    tg.addColorStop(1,   'rgba(0,0,0,0)');
    ctx.fillStyle = tg;
    ctx.beginPath(); ctx.arc(pt.x, pt.y, 8*t, 0, Math.PI*2); ctx.fill();

    // Micro specular
    if (t > 0.65) {
      ctx.beginPath(); ctx.arc(pt.x - 1, pt.y - 1, 1.2*t, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,200,${t*0.7})`; ctx.fill();
    }
  });

  // ── SURFACE TENSION LINES ──
  // Draw subtle radial filaments connecting high spike areas
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.strokeStyle = 'rgba(200,160,60,1)';
  ctx.lineWidth   = 0.5;
  for (let si = 0; si < NUM_SURFACE; si += 4) {
    const s  = surface[si];
    if (s.r < MAX_SPIKE()*0.25) continue;
    const pt = surfaceXY(s);
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(pt.x, pt.y); ctx.stroke();
  }
  ctx.restore();

  // ── DROPLETS ──
  droplets.forEach(d => {
    const dg = ctx.createRadialGradient(d.x - d.r*0.3, d.y - d.r*0.3, 0, d.x, d.y, d.r);
    dg.addColorStop(0,   `rgba(60,45,15,${d.life})`);
    dg.addColorStop(0.6, `rgba(20,15,5,${d.life*0.8})`);
    dg.addColorStop(1,   `rgba(5,4,2,${d.life*0.3})`);
    ctx.fillStyle = dg;
    ctx.beginPath(); ctx.arc(d.x, d.y, d.r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(d.x - d.r*0.3, d.y - d.r*0.3, d.r*0.25, 0, Math.PI*2);
    ctx.fillStyle = `rgba(200,170,80,${d.life*0.4})`; ctx.fill();
  });

  // ── MAGNETIC FIELD LINES (subtle) ──
  ctx.save();
  ctx.globalAlpha = 0.04;
  const fRadius = BASE_RADIUS() * 2.2;
  for (let a = 0; a < Math.PI*2; a += Math.PI/12) {
    const x1 = cx + Math.cos(a) * fRadius * 0.6;
    const y1 = cy + Math.sin(a) * fRadius * 0.6;
    const x2 = cx + Math.cos(a + 0.3) * fRadius;
    const y2 = cy + Math.sin(a + 0.3) * fRadius;
    const fg = ctx.createLinearGradient(cx, cy, x2, y2);
    fg.addColorStop(0,   'rgba(200,160,50,0)');
    fg.addColorStop(0.5, 'rgba(200,160,50,1)');
    fg.addColorStop(1,   'rgba(200,160,50,0)');
    ctx.strokeStyle = fg;
    ctx.lineWidth = 0.6;
    ctx.beginPath(); ctx.moveTo(x1, y1);
    ctx.quadraticCurveTo(cx + Math.cos(a+0.15)*fRadius*1.1, cy + Math.sin(a+0.15)*fRadius*1.1, x2, y2);
    ctx.stroke();
  }
  ctx.restore();

  // ── REFLECTIVE POOL (mirror under the blob) ──
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.scale(1, -0.18);
  ctx.translate(0, -(cy*2 + BASE_RADIUS()*2.8) / 0.18);
  buildBlobPath();
  ctx.fillStyle = 'rgba(200,160,50,0.5)';
  ctx.fill();
  ctx.restore();
}

// ── UI ───────────────────────────────────────────────────────────────────────────
function updateUI() {
  document.getElementById('peakCount').textContent = peaks.length;
  document.getElementById('fieldVal').textContent  = fieldMagnitude.toFixed(2);
}

// ── MAIN LOOP ────────────────────────────────────────────────────────────────────
function loop() {
  physicsStep();
  render();
  updateUI();
  requestAnimationFrame(loop);
}

// Start with mouse centered
mouse.sx = cx; mouse.sy = cy;
loop();
</script>
</body>
</html>
