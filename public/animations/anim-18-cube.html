<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wireframe Cube — FORMA</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #04040c; overflow: hidden; width: 100vw; height: 100vh; cursor: none; }
  canvas { display: block; }
  .label { position: fixed; bottom: 24px; left: 24px; font-family: 'Courier New', monospace; font-size: 11px; letter-spacing: 0.15em; color: rgba(255,255,255,0.2); text-transform: uppercase; pointer-events: none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="label">Wireframe · Drag to rotate</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize(); window.addEventListener('resize', resize);

// 3D math
function mat3x3RotX(a) { return [[1,0,0],[0,Math.cos(a),-Math.sin(a)],[0,Math.sin(a),Math.cos(a)]]; }
function mat3x3RotY(a) { return [[Math.cos(a),0,Math.sin(a)],[0,1,0],[-Math.sin(a),0,Math.cos(a)]]; }
function mat3x3RotZ(a) { return [[Math.cos(a),-Math.sin(a),0],[Math.sin(a),Math.cos(a),0],[0,0,1]]; }
function mulMat(m, v) { return [m[0][0]*v[0]+m[0][1]*v[1]+m[0][2]*v[2], m[1][0]*v[0]+m[1][1]*v[1]+m[1][2]*v[2], m[2][0]*v[0]+m[2][1]*v[1]+m[2][2]*v[2]]; }
function project(v, fov=600) { const z=v[2]+fov; return [v[0]*fov/z+W/2, v[1]*fov/z+H/2, v[2]]; }

// Nested cubes
function makeCube(s) {
  const h = s/2;
  return [
    [-h,-h,-h],[h,-h,-h],[h,h,-h],[-h,h,-h],
    [-h,-h,h],[h,-h,h],[h,h,h],[-h,h,h],
  ];
}
const CUBE_EDGES = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
const FACE_INDICES = [[0,1,2,3],[4,5,6,7],[0,1,5,4],[2,3,7,6],[0,3,7,4],[1,2,6,5]];

const cubes = [
  { size: 200, speed: 1.0, color: '#7c6af7', glow: '#7c6af7' },
  { size: 130, speed: -1.4, color: '#f76af0', glow: '#f76af0' },
  { size: 75, speed: 2.0, color: '#6af7c8', glow: '#6af7c8' },
];

let rotX = 0.3, rotY = 0, rotZ = 0;
let velX = 0, velY = 0;
let dragging = false, lastX = 0, lastY = 0;
let autoRotX = 0.003, autoRotY = 0.005;

document.addEventListener('mousedown', e => { dragging=true; lastX=e.clientX; lastY=e.clientY; velX=velY=0; });
document.addEventListener('mousemove', e => {
  if (!dragging) return;
  velY = (e.clientX-lastX)*0.005; velX = (e.clientY-lastY)*0.005;
  rotX+=velX; rotY+=velY;
  lastX=e.clientX; lastY=e.clientY;
});
document.addEventListener('mouseup', () => dragging=false);
window.addEventListener('touchstart', e => { dragging=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; }, {passive:true});
window.addEventListener('touchmove', e => {
  velY=(e.touches[0].clientX-lastX)*0.005; velX=(e.touches[0].clientY-lastY)*0.005;
  rotX+=velX; rotY+=velY; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;
}, {passive:true});
window.addEventListener('touchend', () => dragging=false);

let time = 0;

function drawCube(verts3d, color) {
  // Project
  const projected = verts3d.map(v => project(v));

  // Draw faces (transparent)
  FACE_INDICES.forEach(face => {
    const avgZ = face.reduce((sum,i) => sum+projected[i][2], 0)/4;
    const alpha = 0.02 + (avgZ+300)/1200*0.04;
    ctx.beginPath();
    face.forEach((vi,i) => {
      const p=projected[vi];
      i===0 ? ctx.moveTo(p[0],p[1]) : ctx.lineTo(p[0],p[1]);
    });
    ctx.closePath();
    ctx.fillStyle = color+Math.floor(alpha*255).toString(16).padStart(2,'0');
    ctx.fill();
  });

  // Draw edges
  CUBE_EDGES.forEach(([a,b]) => {
    const pa=projected[a], pb=projected[b];
    const avgZ=(pa[2]+pb[2])/2;
    const alpha = 0.3 + (avgZ+300)/600*0.5;
    ctx.beginPath(); ctx.moveTo(pa[0],pa[1]); ctx.lineTo(pb[0],pb[1]);
    ctx.strokeStyle = color+Math.floor(Math.min(255,alpha*255)).toString(16).padStart(2,'0');
    ctx.lineWidth = 1 + (avgZ+300)/600*1.5;
    ctx.stroke();
  });

  // Draw vertices
  projected.forEach(p => {
    const alpha = 0.5+(p[2]+300)/600*0.5;
    ctx.beginPath(); ctx.arc(p[0],p[1], 2+(p[2]+300)/300, 0, Math.PI*2);
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = alpha;
    ctx.fill();
    ctx.globalAlpha = 1;
  });
}

function draw() {
  time += 0.01;
  if (!dragging) { velX*=0.95; velY*=0.95; rotX+=velX+autoRotX; rotY+=velY+autoRotY; rotZ+=0.001; }

  ctx.fillStyle = 'rgba(4,4,12,0.25)';
  ctx.fillRect(0,0,W,H);

  // Glow under
  const cg = ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,200);
  cg.addColorStop(0,'rgba(124,106,247,0.06)');
  cg.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=cg; ctx.fillRect(0,0,W,H);

  cubes.forEach((cubeDef, ci) => {
    const verts = makeCube(cubeDef.size);
    const offset = ci * 0.8;
    const rx = mat3x3RotX(rotX + offset * cubeDef.speed);
    const ry = mat3x3RotY(rotY * cubeDef.speed + time*0.1*ci);
    const rz = mat3x3RotZ(rotZ + offset * 0.5);
    const transformed = verts.map(v => {
      let t = mulMat(rx, v);
      t = mulMat(ry, t);
      t = mulMat(rz, t);
      return t;
    });
    ctx.shadowColor = cubeDef.color; ctx.shadowBlur = 12;
    drawCube(transformed, cubeDef.color);
    ctx.shadowBlur = 0;
  });

  // Cursor
  const m = { x: window.event?.clientX||W/2, y: window.event?.clientY||H/2 };
  ctx.beginPath(); ctx.arc(lastX||W/2, lastY||H/2, 4, 0, Math.PI*2);
  ctx.fillStyle = dragging ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.4)'; ctx.fill();

  requestAnimationFrame(draw);
}

// Track last mouse for cursor
document.addEventListener('mousemove', e => { lastX=e.clientX; lastY=e.clientY; });
draw();
</script>
</body>
</html>
