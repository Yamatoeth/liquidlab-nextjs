<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AURUM — Crystal Collection</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,300;1,400&family=Cinzel:wght@400;600;900&display=swap');

  *, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }

  :root {
    --gold:    #c9a84c;
    --gold2:   #e8c96d;
    --gold3:   #f5e6a3;
    --amber:   #b8732a;
    --dark:    #080604;
    --deep:    #0f0b05;
    --obsid:   #1a1208;
    --cream:   #f0e6c8;
    --border:  rgba(201,168,76,0.18);
    --glow:    rgba(201,168,76,0.35);
  }

  html, body {
    width:100%; height:100%;
    background: var(--dark);
    overflow: hidden;
    cursor: none;
    font-family: 'Cormorant Garamond', serif;
  }

  canvas { display:block; position:fixed; inset:0; z-index:0; }

  /* ── Cursor ── */
  #cur {
    position:fixed; pointer-events:none; z-index:9999;
    width:6px; height:6px; border-radius:50%;
    background: var(--gold2);
    transform:translate(-50%,-50%);
    box-shadow: 0 0 10px var(--gold), 0 0 24px rgba(201,168,76,0.4);
    mix-blend-mode: screen;
  }
  #cur-ring {
    position:fixed; pointer-events:none; z-index:9998;
    width:36px; height:36px; border-radius:50%;
    border:1px solid rgba(201,168,76,0.4);
    transform:translate(-50%,-50%);
    transition: width .35s ease, height .35s ease, border-color .3s;
  }
  #cur-ring.hover { width:56px; height:56px; border-color:rgba(201,168,76,0.9); }

  /* ── Vignette + grain ── */
  #vignette {
    position:fixed; inset:0; pointer-events:none; z-index:4;
    background: radial-gradient(ellipse at 50% 60%, transparent 30%, rgba(8,6,4,0.92) 100%);
  }
  #grain {
    position:fixed; inset:0; pointer-events:none; z-index:5; opacity:.5;
    background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.05'/%3E%3C/svg%3E");
  }

  /* ── Decorative frame lines ── */
  .frame-line {
    position:fixed; pointer-events:none; z-index:6;
    background: linear-gradient(to right, transparent, var(--gold), transparent);
    height:1px; left:0; right:0; opacity:.2;
  }
  .frame-line.top    { top:0; }
  .frame-line.bottom { bottom:0; }
  .frame-v {
    position:fixed; pointer-events:none; z-index:6;
    background: linear-gradient(to bottom, transparent, var(--gold), transparent);
    width:1px; top:0; bottom:0; opacity:.15;
  }
  .frame-v.left  { left:0; }
  .frame-v.right { right:0; }

  /* ── Corner ornaments ── */
  .corner {
    position:fixed; z-index:7; pointer-events:none;
    width:48px; height:48px;
  }
  .corner svg { width:100%; height:100%; }
  .corner.tl { top:20px;    left:20px; }
  .corner.tr { top:20px;    right:20px;  transform:scaleX(-1); }
  .corner.bl { bottom:20px; left:20px;   transform:scaleY(-1); }
  .corner.br { bottom:20px; right:20px;  transform:scale(-1); }

  /* ── UI overlay ── */
  #ui {
    position:fixed; inset:0; z-index:10; pointer-events:none;
    padding:44px 52px;
    display:flex; flex-direction:column; justify-content:space-between;
  }

  /* Header */
  .hd { display:flex; justify-content:space-between; align-items:flex-start; }

  .brand-block { display:flex; flex-direction:column; gap:6px; }

  .logo {
    font-family:'Cinzel', serif; font-weight:900;
    font-size:36px; letter-spacing:14px;
    color: var(--gold2);
    text-shadow: 0 0 40px rgba(201,168,76,0.5), 0 2px 0 rgba(0,0,0,0.8);
    animation: goldPulse 5s ease-in-out infinite alternate;
  }
  @keyframes goldPulse {
    from { text-shadow: 0 0 30px rgba(201,168,76,0.3), 0 2px 0 rgba(0,0,0,0.8); }
    to   { text-shadow: 0 0 60px rgba(201,168,76,0.6), 0 0 120px rgba(201,168,76,0.2), 0 2px 0 rgba(0,0,0,0.8); }
  }

  .logo-rule {
    width:100%; height:1px;
    background: linear-gradient(to right, var(--gold), var(--amber), transparent);
  }
  .logo-sub {
    font-size:10px; letter-spacing:6px; color:rgba(201,168,76,0.45);
    text-transform:uppercase; font-style:italic;
  }

  .hd-right {
    display:flex; flex-direction:column; align-items:flex-end; gap:10px;
    opacity:0; animation: fadeIn .8s ease 1s forwards;
  }

  .status-pill {
    display:flex; align-items:center; gap:8px;
    padding:6px 16px;
    border:1px solid var(--border);
    background:rgba(15,11,5,0.7);
    backdrop-filter:blur(12px);
  }
  .gold-dot {
    width:6px; height:6px; border-radius:50%;
    background: var(--gold);
    box-shadow: 0 0 8px var(--gold);
    animation: dotBlink 2s ease-in-out infinite;
  }
  @keyframes dotBlink { 0%,100%{opacity:1} 50%{opacity:.3} }
  .status-text {
    font-family:'Cinzel', serif; font-size:9px;
    letter-spacing:4px; color:rgba(201,168,76,0.6);
    text-transform:uppercase;
  }

  .season-label {
    font-size:11px; letter-spacing:5px; font-style:italic;
    color:rgba(201,168,76,0.3);
  }

  /* Center left text */
  .center-copy {
    position:absolute; left:52px; top:50%; transform:translateY(-50%);
    max-width:360px;
  }

  .eyebrow {
    font-size:10px; letter-spacing:6px; text-transform:uppercase; font-style:italic;
    color:rgba(201,168,76,0.5); margin-bottom:18px;
    opacity:0; animation:fadeUp .7s ease .6s forwards;
  }

  .headline {
    font-family:'Cinzel', serif; font-weight:600;
    font-size:clamp(28px,3.2vw,50px);
    line-height:1.15; color: var(--cream);
    margin-bottom:22px;
    opacity:0; animation:fadeUp .7s ease .8s forwards;
    text-shadow:0 2px 30px rgba(0,0,0,0.9);
  }
  .headline span {
    background:linear-gradient(135deg, var(--gold3), var(--gold), var(--amber));
    -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
  }

  .body-copy {
    font-size:15px; line-height:1.9; font-style:italic;
    color:rgba(240,230,200,0.4); font-weight:300;
    opacity:0; animation:fadeUp .7s ease 1s forwards;
  }

  .divider {
    width:60px; height:1px; margin:24px 0;
    background:linear-gradient(to right, var(--gold), transparent);
    opacity:0; animation:fadeUp .7s ease 1.1s forwards;
  }

  .cta-row {
    display:flex; gap:14px; pointer-events:all;
    opacity:0; animation:fadeUp .7s ease 1.2s forwards;
  }

  .btn-gold {
    padding:13px 34px;
    border:1px solid rgba(201,168,76,0.6);
    background:transparent; position:relative; overflow:hidden;
    font-family:'Cinzel', serif; font-size:10px;
    letter-spacing:5px; text-transform:uppercase; cursor:none;
    color: var(--gold2); transition:color .4s;
  }
  .btn-gold::before {
    content:''; position:absolute; inset:0;
    background:linear-gradient(135deg, var(--gold), var(--amber));
    transform:translateX(-101%);
    transition:transform .45s cubic-bezier(.4,0,.2,1);
  }
  .btn-gold:hover::before { transform:translateX(0); }
  .btn-gold:hover { color: var(--dark); }

  .btn-ghost {
    padding:13px 34px;
    border:1px solid rgba(201,168,76,0.15);
    background:transparent;
    font-family:'Cinzel', serif; font-size:10px;
    letter-spacing:5px; text-transform:uppercase; cursor:none;
    color:rgba(201,168,76,0.35);
    transition:border-color .3s, color .3s;
  }
  .btn-ghost:hover { border-color:rgba(201,168,76,0.4); color:rgba(201,168,76,0.7); }

  /* Bottom */
  .ft { display:flex; justify-content:space-between; align-items:flex-end; }

  .collection-stats {
    display:flex; gap:44px;
    opacity:0; animation:fadeUp .7s ease 1.4s forwards;
  }
  .stat { display:flex; flex-direction:column; gap:4px; }
  .stat-n {
    font-family:'Cinzel', serif; font-size:26px; font-weight:600;
    color: var(--cream); line-height:1;
    text-shadow:0 0 20px rgba(201,168,76,0.3);
  }
  .stat-n em { color: var(--gold); font-style:normal; }
  .stat-l { font-size:9px; letter-spacing:4px; text-transform:uppercase; font-style:italic; color:rgba(201,168,76,0.3); }

  .ft-right {
    display:flex; flex-direction:column; align-items:flex-end; gap:6px;
    opacity:0; animation:fadeIn .8s ease 1.5s forwards;
  }
  .grow-label {
    font-family:'Cinzel', serif; font-size:9px; letter-spacing:4px;
    color:rgba(201,168,76,0.4); text-transform:uppercase;
    animation:breathe 3s ease-in-out infinite;
  }
  @keyframes breathe { 0%,100%{opacity:.3} 50%{opacity:.8} }
  .progress-track {
    width:160px; height:2px;
    background:rgba(201,168,76,0.1); position:relative; overflow:hidden;
  }
  .progress-fill {
    position:absolute; top:0; left:0; height:100%;
    background:linear-gradient(to right, var(--amber), var(--gold2));
    box-shadow:0 0 8px var(--gold);
    width:0%; animation:progressAnim 8s ease-in-out infinite;
  }
  @keyframes progressAnim {
    0%{width:0%} 50%{width:100%} 100%{width:0%}
  }

  @keyframes fadeUp { from{opacity:0;transform:translateY(14px)} to{opacity:1;transform:translateY(0)} }
  @keyframes fadeIn { from{opacity:0} to{opacity:1} }

  /* Tooltip */
  #tip {
    position:fixed; z-index:200; pointer-events:none;
    padding:8px 16px;
    border:1px solid var(--border);
    background:rgba(8,6,4,0.85);
    backdrop-filter:blur(16px);
    font-family:'Cormorant Garamond', serif;
    font-size:12px; letter-spacing:3px; font-style:italic;
    color:var(--gold2); text-transform:uppercase;
    opacity:0; transition:opacity .25s;
    white-space:nowrap;
  }
</style>
</head>
<body>

<div id="cur"></div>
<div id="cur-ring"></div>
<div id="vignette"></div>
<div id="grain"></div>
<div class="frame-line top"></div>
<div class="frame-line bottom"></div>
<div class="frame-v left"></div>
<div class="frame-v right"></div>
<div id="tip"></div>

<!-- Corner ornaments -->
<div class="corner tl"><svg viewBox="0 0 48 48" fill="none"><path d="M2 46 L2 2 L46 2" stroke="#c9a84c" stroke-width="1" opacity="0.6"/><path d="M2 2 L12 2" stroke="#c9a84c" stroke-width="2" opacity="0.9"/><path d="M2 2 L2 12" stroke="#c9a84c" stroke-width="2" opacity="0.9"/></svg></div>
<div class="corner tr"><svg viewBox="0 0 48 48" fill="none"><path d="M2 46 L2 2 L46 2" stroke="#c9a84c" stroke-width="1" opacity="0.6"/><path d="M2 2 L12 2" stroke="#c9a84c" stroke-width="2" opacity="0.9"/><path d="M2 2 L2 12" stroke="#c9a84c" stroke-width="2" opacity="0.9"/></svg></div>
<div class="corner bl"><svg viewBox="0 0 48 48" fill="none"><path d="M2 46 L2 2 L46 2" stroke="#c9a84c" stroke-width="1" opacity="0.6"/><path d="M2 2 L12 2" stroke="#c9a84c" stroke-width="2" opacity="0.9"/><path d="M2 2 L2 12" stroke="#c9a84c" stroke-width="2" opacity="0.9"/></svg></div>
<div class="corner br"><svg viewBox="0 0 48 48" fill="none"><path d="M2 46 L2 2 L46 2" stroke="#c9a84c" stroke-width="1" opacity="0.6"/><path d="M2 2 L12 2" stroke="#c9a84c" stroke-width="2" opacity="0.9"/><path d="M2 2 L2 12" stroke="#c9a84c" stroke-width="2" opacity="0.9"/></svg></div>

<div id="ui">
  <div class="hd">
    <div class="brand-block">
      <div class="logo">AURUM</div>
      <div class="logo-rule"></div>
      <div class="logo-sub">Collection de Cristaux — Édition Limitée</div>
    </div>
    <div class="hd-right">
      <div class="status-pill"><div class="gold-dot"></div><div class="status-text">Croissance Active</div></div>
      <div class="season-label">Saison IV · MMXXVI</div>
    </div>
  </div>

  <div class="center-copy">
    <div class="eyebrow">— Minéraux d'exception</div>
    <h1 class="headline">Né des<br>profondeurs<br>de la <span>terre</span></h1>
    <div class="divider"></div>
    <p class="body-copy">Chaque cristal est unique,<br>formé sur des millénaires.<br>Observez la nature à l'œuvre.</p>
    <div class="cta-row" style="margin-top:28px">
      <button class="btn-gold">Acquérir</button>
      <button class="btn-ghost">Catalogue</button>
    </div>
  </div>

  <div class="ft">
    <div class="collection-stats">
      <div class="stat"><div class="stat-n">47<em>K</em></div><div class="stat-l">Pièces rares</div></div>
      <div class="stat"><div class="stat-n">99<em>%</em></div><div class="stat-l">Authenticité</div></div>
      <div class="stat"><div class="stat-n">12<em>M</em></div><div class="stat-l">Valeur estimée</div></div>
    </div>
    <div class="ft-right">
      <div class="grow-label">Croissance en cours</div>
      <div class="progress-track"><div class="progress-fill"></div></div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ═══════════════════════════════════════
// SETUP
// ═══════════════════════════════════════
const W = window.innerWidth, H = window.innerHeight;
const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
renderer.setSize(W, H);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.4;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x080604);
scene.fog = new THREE.FogExp2(0x080604, 0.022);

const camera = new THREE.PerspectiveCamera(52, W / H, 0.1, 300);
camera.position.set(0, 8, 22);
camera.lookAt(0, 2, 0);

// ═══════════════════════════════════════
// MOUSE
// ═══════════════════════════════════════
const mouse = { x: 0, y: 0 };
const curEl   = document.getElementById('cur');
const ringEl  = document.getElementById('cur-ring');
const tipEl   = document.getElementById('tip');

document.addEventListener('mousemove', e => {
  mouse.x = (e.clientX / W) * 2 - 1;
  mouse.y = -(e.clientY / H) * 2 + 1;
  curEl.style.left  = e.clientX + 'px';
  curEl.style.top   = e.clientY + 'px';
  ringEl.style.left = e.clientX + 'px';
  ringEl.style.top  = e.clientY + 'px';
  tipEl.style.left  = (e.clientX + 22) + 'px';
  tipEl.style.top   = (e.clientY - 14) + 'px';
});

// ═══════════════════════════════════════
// GROUND PLANE — polished obsidian
// ═══════════════════════════════════════
const groundGeo = new THREE.PlaneGeometry(60, 60, 1, 1);
const groundMat = new THREE.MeshStandardMaterial({
  color: 0x0a0704,
  metalness: 0.9,
  roughness: 0.15,
  envMapIntensity: 1,
});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
ground.receiveShadow = true;
scene.add(ground);

// Subtle grid on ground
const gridHelper = new THREE.GridHelper(50, 40, 0x1a1208, 0x110e06);
gridHelper.position.y = 0.001;
gridHelper.material.transparent = true;
gridHelper.material.opacity = 0.5;
scene.add(gridHelper);

// ═══════════════════════════════════════
// CRYSTAL FACTORY
// ═══════════════════════════════════════
function makeCrystalGeometry(sides, height, topRatio, twist) {
  // Build a custom crystal: base polygon → tapered top spike
  const shape = new THREE.CylinderGeometry(
    topRatio,       // top radius
    1.0,            // bottom radius
    height,         // height
    sides,          // radial segments
    8,              // height segments
    false
  );
  // Apply twist by rotating vertices progressively
  const pos = shape.attributes.position;
  for (let i = 0; i < pos.count; i++) {
    const y = pos.getY(i);
    const t = (y / height + 0.5); // 0..1 bottom to top
    const angle = t * twist;
    const x = pos.getX(i);
    const z = pos.getZ(i);
    pos.setX(i, x * Math.cos(angle) - z * Math.sin(angle));
    pos.setZ(i, x * Math.sin(angle) + z * Math.cos(angle));
  }
  pos.needsUpdate = true;
  shape.computeVertexNormals();
  return shape;
}

// Gold material variants
function goldMat(brightness, emissive) {
  return new THREE.MeshStandardMaterial({
    color: new THREE.Color(brightness, brightness * 0.84, brightness * 0.3),
    metalness: 0.95,
    roughness: 0.08 + Math.random() * 0.12,
    emissive: new THREE.Color(emissive, emissive * 0.7, 0),
    emissiveIntensity: 0.15,
  });
}

// Crystal cluster data
const clusterDefs = [
  // [x, z, count, baseScale, spread]
  [  0,    0,   7,  1.6, 1.8 ],   // hero center
  [ -5,   -3,   4,  0.9, 1.2 ],
  [  5.5, -2,   4,  1.0, 1.1 ],
  [ -3.5,  3,   3,  0.7, 0.9 ],
  [  4,    3.5, 3,  0.75,1.0 ],
  [ -7,    1,   3,  0.6, 0.8 ],
  [  7,    1,   3,  0.55,0.7 ],
  [  0,   -5,   5,  0.8, 1.3 ],
  [ -2,    5,   2,  0.5, 0.6 ],
  [  2.5,  5.5, 2,  0.45,0.6 ],
];

const crystals = []; // {mesh, targetScaleY, currentScaleY, delay, speed, baseY, cluster}

clusterDefs.forEach((def, ci) => {
  const [cx, cz, count, baseScale, spread] = def;
  for (let i = 0; i < count; i++) {
    const sides    = 4 + Math.floor(Math.random() * 3); // 4..6 sides
    const height   = 1.8 + Math.random() * 3.5;
    const topR     = 0.02 + Math.random() * 0.12;
    const twist    = (Math.random() - 0.5) * 0.6;
    const geo      = makeCrystalGeometry(sides, height, topR, twist);

    const bright   = 0.5 + Math.random() * 0.45;
    const emiss    = 0.05 + Math.random() * 0.12;
    const mat      = goldMat(bright, emiss);

    const mesh     = new THREE.Mesh(geo, mat);
    mesh.castShadow    = true;
    mesh.receiveShadow = true;

    // Position within cluster
    const angle  = Math.random() * Math.PI * 2;
    const radius = Math.random() * spread;
    const px     = cx + Math.cos(angle) * radius;
    const pz     = cz + Math.sin(angle) * radius;

    // Tilt slightly outward from cluster center
    const tiltAng  = (Math.random() - 0.5) * 0.25;
    const tiltAxis = new THREE.Vector3(
      Math.cos(angle + Math.PI / 2), 0,
      Math.sin(angle + Math.PI / 2)
    ).normalize();
    mesh.setRotationFromAxisAngle(tiltAxis, tiltAng);
    mesh.rotateY(Math.random() * Math.PI * 2);

    const finalScaleXZ = (baseScale * (0.4 + Math.random() * 0.7));
    const finalScaleY  = baseScale * (0.5 + Math.random() * 1.0);

    mesh.position.set(px, -height * finalScaleY * 0.5, pz); // start underground
    mesh.scale.set(finalScaleXZ, 0.001, finalScaleXZ);

    scene.add(mesh);
    crystals.push({
      mesh,
      targetScaleY: finalScaleY,
      currentScaleY: 0.001,
      finalScaleXZ,
      height,
      baseY: height * finalScaleY * 0.5,
      px, pz,
      delay: ci * 0.18 + i * 0.09 + Math.random() * 0.3,
      speed: 0.4 + Math.random() * 0.6,
      grown: false,
      pulse: Math.random() * Math.PI * 2,
      pulseSpeed: 0.5 + Math.random() * 1.0,
    });
  }
});

// ═══════════════════════════════════════
// CRYSTAL DUST PARTICLES
// ═══════════════════════════════════════
const DUST = 1800;
const dustPos = new Float32Array(DUST * 3);
const dustCol = new Float32Array(DUST * 3);
const dustVel = [];

for (let i = 0; i < DUST; i++) {
  const r = 2 + Math.random() * 12;
  const a = Math.random() * Math.PI * 2;
  dustPos[i*3]   = Math.cos(a) * r;
  dustPos[i*3+1] = Math.random() * 8;
  dustPos[i*3+2] = Math.sin(a) * r;

  const t = Math.random();
  // Gold spectrum: amber → gold → pale gold
  dustCol[i*3]   = 0.55 + t * 0.35;
  dustCol[i*3+1] = 0.38 + t * 0.48;
  dustCol[i*3+2] = 0.05 + t * 0.15;

  dustVel.push({
    vx: (Math.random() - 0.5) * 0.008,
    vy: 0.004 + Math.random() * 0.012,
    vz: (Math.random() - 0.5) * 0.008,
  });
}

const dustGeo = new THREE.BufferGeometry();
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
dustGeo.setAttribute('color',    new THREE.BufferAttribute(dustCol, 3));

const dustMat = new THREE.PointsMaterial({
  size: 0.05,
  vertexColors: true,
  transparent: true,
  opacity: 0.65,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  sizeAttenuation: true,
});
scene.add(new THREE.Points(dustGeo, dustMat));

// ═══════════════════════════════════════
// LIGHT SHAFTS (volumetric look via cones)
// ═══════════════════════════════════════
function addLightShaft(x, z, color, opacity) {
  const geo = new THREE.ConeGeometry(1.2, 14, 16, 1, true);
  const mat = new THREE.MeshBasicMaterial({
    color, transparent: true, opacity,
    side: THREE.BackSide, blending: THREE.AdditiveBlending, depthWrite: false,
  });
  const cone = new THREE.Mesh(geo, mat);
  cone.position.set(x, 7, z);
  cone.rotation.x = Math.PI; // point downward
  scene.add(cone);
  return cone;
}

const shaft1 = addLightShaft( 0,   0,   0xc9a84c, 0.04);
const shaft2 = addLightShaft(-4,  -3,   0xe8c96d, 0.025);
const shaft3 = addLightShaft( 5,  -2,   0xb8732a, 0.03);

// ═══════════════════════════════════════
// FLOATING GOLD FLAKES
// ═══════════════════════════════════════
const flakes = [];
for (let i = 0; i < 18; i++) {
  const geo = new THREE.OctahedronGeometry(0.04 + Math.random() * 0.09, 0);
  const mat = new THREE.MeshStandardMaterial({
    color: 0xe8c96d, metalness: 1, roughness: 0,
    emissive: 0xc9a84c, emissiveIntensity: 0.4,
  });
  const m = new THREE.Mesh(geo, mat);
  const r = 3 + Math.random() * 8;
  const a = Math.random() * Math.PI * 2;
  m.position.set(Math.cos(a)*r, 1 + Math.random() * 6, Math.sin(a)*r);
  m.userData = {
    oa: a, r,
    speed:  0.12 + Math.random() * 0.25,
    yOff:   Math.random() * Math.PI * 2,
    rotSpd: (Math.random() - 0.5) * 0.04,
  };
  scene.add(m);
  flakes.push(m);
}

// ═══════════════════════════════════════
// LIGHTS
// ═══════════════════════════════════════
scene.add(new THREE.AmbientLight(0x1a1005, 3));

const keyLight = new THREE.SpotLight(0xf5e6a3, 4, 40, Math.PI / 5, 0.3, 1.5);
keyLight.position.set(0, 18, 5);
keyLight.target.position.set(0, 0, 0);
keyLight.castShadow = true;
keyLight.shadow.mapSize.width  = 1024;
keyLight.shadow.mapSize.height = 1024;
scene.add(keyLight);
scene.add(keyLight.target);

const fillLight = new THREE.PointLight(0xb8732a, 3, 20);
fillLight.position.set(-8, 6, -4);
scene.add(fillLight);

const rimLight = new THREE.PointLight(0xe8c96d, 2, 18);
rimLight.position.set(8, 4, -6);
scene.add(rimLight);

const underGlow = new THREE.PointLight(0x7a4a10, 2, 10);
underGlow.position.set(0, -1, 0);
scene.add(underGlow);

// ═══════════════════════════════════════
// RAYCASTER
// ═══════════════════════════════════════
const raycaster = new THREE.Raycaster();
let hoveredCrystal = null;
const crystalMeshes = crystals.map(c => c.mesh);
const crystalNames  = ['Topaze d\'Or', 'Citrine Impériale', 'Saphir Doré',
  'Ambre Cristallisé', 'Quartz Aurique', 'Pyrite Noble', 'Chrysoberyl'];

// Click to regrow
document.addEventListener('click', () => {
  crystals.forEach(c => {
    c.currentScaleY = 0.001;
    c.grown = false;
    c.delay = Math.random() * 1.2;
    c.mesh.scale.set(c.finalScaleXZ, 0.001, c.finalScaleXZ);
    c.mesh.position.y = -c.height * c.targetScaleY * 0.5;
  });
});

// ═══════════════════════════════════════
// ANIMATION
// ═══════════════════════════════════════
let t = 0;
let zoomTarget = 22;

window.addEventListener('wheel', e => {
  zoomTarget += e.deltaY * 0.02;
  zoomTarget = Math.max(10, Math.min(35, zoomTarget));
});

function animate() {
  requestAnimationFrame(animate);
  t += 0.012;

  // Camera parallax
  const camTX = mouse.x * 3.5;
  const camTY = 8 + mouse.y * 2.5;
  camera.position.x += (camTX - camera.position.x) * 0.035;
  camera.position.y += (camTY - camera.position.y) * 0.035;
  camera.position.z += (zoomTarget - camera.position.z) * 0.05;
  camera.lookAt(0, 2, 0);

  // Grow crystals
  crystals.forEach(c => {
    if (t < c.delay) return;
    if (c.grown) {
      // Subtle pulse once grown
      const pulse = 1 + Math.sin(t * c.pulseSpeed + c.pulse) * 0.012;
      c.mesh.scale.set(c.finalScaleXZ * pulse, c.currentScaleY, c.finalScaleXZ * pulse);
      c.mesh.material.emissiveIntensity = 0.12 + Math.sin(t * c.pulseSpeed + c.pulse) * 0.06;
      return;
    }
    // Ease toward target
    const ease = 1 - Math.exp(-c.speed * (t - c.delay) * 0.5);
    c.currentScaleY = c.targetScaleY * ease;
    c.mesh.scale.set(c.finalScaleXZ, c.currentScaleY, c.finalScaleXZ);
    c.mesh.position.y = c.baseY * ease - c.height * c.targetScaleY * 0.5 * (1 - ease);
    if (ease > 0.995) c.grown = true;
  });

  // Dust particles
  const dp = dustGeo.attributes.position.array;
  for (let i = 0; i < DUST; i++) {
    dp[i*3]   += dustVel[i].vx;
    dp[i*3+1] += dustVel[i].vy;
    dp[i*3+2] += dustVel[i].vz;
    if (dp[i*3+1] > 10) {
      dp[i*3+1] = 0;
      const r = 2 + Math.random() * 12;
      const a = Math.random() * Math.PI * 2;
      dp[i*3]   = Math.cos(a) * r;
      dp[i*3+2] = Math.sin(a) * r;
    }
  }
  dustGeo.attributes.position.needsUpdate = true;

  // Gold flakes orbit
  flakes.forEach(f => {
    const { oa, r, speed, yOff, rotSpd } = f.userData;
    const a = oa + t * speed * 0.2;
    f.position.x = Math.cos(a) * r;
    f.position.z = Math.sin(a) * r;
    f.position.y = 1.5 + Math.sin(t * speed + yOff) * 1.5;
    f.rotation.x += rotSpd;
    f.rotation.y += rotSpd * 0.7;
  });

  // Light shafts
  shaft1.material.opacity = 0.03 + Math.sin(t * 0.8) * 0.015;
  shaft2.material.opacity = 0.02 + Math.sin(t * 0.6 + 1) * 0.01;
  shaft3.material.opacity = 0.025 + Math.sin(t * 0.7 + 2) * 0.012;

  // Key light flicker (subtle candlelight)
  keyLight.intensity = 4 + Math.sin(t * 3.1) * 0.12 + Math.sin(t * 7.3) * 0.06;
  fillLight.intensity = 3 + Math.sin(t * 2.1) * 0.3;
  rimLight.position.x = 8 + Math.sin(t * 0.4) * 2;
  rimLight.position.z = -6 + Math.cos(t * 0.3) * 2;

  // Raycaster hover
  raycaster.setFromCamera({ x: mouse.x, y: mouse.y }, camera);
  const hits = raycaster.intersectObjects(crystalMeshes);

  if (hits.length > 0) {
    const obj = hits[0].object;
    if (hoveredCrystal !== obj) {
      if (hoveredCrystal) {
        hoveredCrystal.material.emissiveIntensity = 0.15;
        hoveredCrystal.scale.multiplyScalar(1 / 1.05);
      }
      hoveredCrystal = obj;
      hoveredCrystal.material.emissiveIntensity = 0.8;
      const name = crystalNames[Math.floor(Math.random() * crystalNames.length)];
      const price = (Math.random() * 9000 + 1000).toFixed(0);
      tipEl.textContent = `${name}  ·  ${price} €`;
      tipEl.style.opacity = '1';
    }
    ringEl.classList.add('hover');
  } else {
    if (hoveredCrystal) {
      hoveredCrystal.material.emissiveIntensity = 0.15;
      hoveredCrystal = null;
      tipEl.style.opacity = '0';
    }
    ringEl.classList.remove('hover');
  }

  renderer.render(scene, camera);
}

animate();

// Resize
window.addEventListener('resize', () => {
  const w = innerWidth, h = innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});
</script>
</body>
</html>
