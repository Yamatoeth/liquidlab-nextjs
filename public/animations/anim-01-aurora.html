<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aurora Ambient — FORMA</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #04040a; overflow: hidden; width: 100vw; height: 100vh; }
  canvas { display: block; }
  .label {
    position: fixed; bottom: 24px; left: 24px;
    font-family: 'Courier New', monospace;
    font-size: 11px; letter-spacing: 0.15em;
    color: rgba(255,255,255,0.25);
    text-transform: uppercase;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="label">Aurora Ambient · Move cursor</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, mouse = { x: 0.5, y: 0.5 }, target = { x: 0.5, y: 0.5 };

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => {
  target.x = e.clientX / W;
  target.y = e.clientY / H;
});
window.addEventListener('touchmove', e => {
  target.x = e.touches[0].clientX / W;
  target.y = e.touches[0].clientY / H;
}, { passive: true });

// Orbs config
const orbs = [
  { x: 0.2, y: 0.3, r: 0.55, color: [120, 80, 255], speed: 0.0008, phase: 0 },
  { x: 0.8, y: 0.7, r: 0.50, color: [240, 60, 200], speed: 0.0011, phase: 2 },
  { x: 0.5, y: 0.5, r: 0.45, color: [60, 200, 255], speed: 0.0006, phase: 4 },
  { x: 0.3, y: 0.8, r: 0.40, color: [100, 255, 180], speed: 0.0009, phase: 1 },
  { x: 0.7, y: 0.2, r: 0.38, color: [255, 140, 80], speed: 0.0007, phase: 3 },
];

let time = 0;

function lerp(a, b, t) { return a + (b - a) * t; }

function draw() {
  time++;
  mouse.x = lerp(mouse.x, target.x, 0.04);
  mouse.y = lerp(mouse.y, target.y, 0.04);

  ctx.fillStyle = 'rgba(4,4,10,0.18)';
  ctx.fillRect(0, 0, W, H);

  orbs.forEach((orb, i) => {
    const drift = Math.sin(time * orb.speed * 1000 + orb.phase) * 0.12;
    const driftY = Math.cos(time * orb.speed * 800 + orb.phase) * 0.10;
    
    // Mouse influence
    const mx = (mouse.x - 0.5) * 0.18 * (i % 2 === 0 ? 1 : -1);
    const my = (mouse.y - 0.5) * 0.14 * (i % 2 === 0 ? -1 : 1);

    const cx = (orb.x + drift + mx) * W;
    const cy = (orb.y + driftY + my) * H;
    const radius = orb.r * Math.min(W, H);

    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
    const [r, g, b] = orb.color;
    const alpha = 0.13 + Math.sin(time * 0.02 + orb.phase) * 0.04;
    grad.addColorStop(0, `rgba(${r},${g},${b},${alpha})`);
    grad.addColorStop(0.5, `rgba(${r},${g},${b},${alpha * 0.4})`);
    grad.addColorStop(1, `rgba(${r},${g},${b},0)`);

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(cx, cy, radius * 1.2, radius * 0.8, time * 0.001 + orb.phase, 0, Math.PI * 2);
    ctx.fill();
  });

  // Noise grain overlay
  const imageData = ctx.getImageData(0, 0, W, H);
  // skip heavy grain, use CSS instead

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
