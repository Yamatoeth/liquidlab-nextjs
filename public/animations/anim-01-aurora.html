<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aurora Ambient — FORMA</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #04040a; overflow: hidden; width: 100vw; height: 100vh; }
  canvas { display: block; }
  .label {
    position: fixed; bottom: 24px; left: 24px;
    font-family: 'Courier New', monospace;
    font-size: 11px; letter-spacing: 0.15em;
    color: rgba(255,255,255,0.25);
    text-transform: uppercase;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="label">Aurora Ambient · Move cursor</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, mouse = { x: 0.5, y: 0.5 }, target = { x: 0.5, y: 0.5 };

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => {
  target.x = e.clientX / W;
  target.y = e.clientY / H;
});
window.addEventListener('touchmove', e => {
  target.x = e.touches[0].clientX / W;
  target.y = e.touches[0].clientY / H;
}, { passive: true });

// ─── Variables exposées — contrôlables via postMessage ───────────────────────
let speed         = 1;      // multiplicateur de vitesse globale
let trail         = 0.18;   // opacité du fond (persistence / traînée)
let intensity     = 1;      // opacité/éclat des orbes
let mouseInfluence = 0.18;  // ampleur du déplacement souris

// ─── Orbs config (base data — immutable) ────────────────────────────────────
const baseOrbs = [
  { x: 0.2, y: 0.3, r: 0.55, color: [120, 80, 255], speed: 0.0008, phase: 0 },
  { x: 0.8, y: 0.7, r: 0.50, color: [240, 60, 200], speed: 0.0011, phase: 2 },
  { x: 0.5, y: 0.5, r: 0.45, color: [60, 200, 255], speed: 0.0006, phase: 4 },
  { x: 0.3, y: 0.8, r: 0.40, color: [100, 255, 180], speed: 0.0009, phase: 1 },
  { x: 0.7, y: 0.2, r: 0.38, color: [255, 140, 80],  speed: 0.0007, phase: 3 },
];

// ─── Live params (cible) ─────────────────────────────────────────────────────
let params = {
  speed:         1,
  intensity:     1,
  particleSize:  1,
  offsetY:       0,
  particleCount: baseOrbs.length,
  colorA:        null,
  colorB:        null,
  hueShift:      0,
  enableGlow:    true,
};

// ─── Helpers ─────────────────────────────────────────────────────────────────
function hexToRgb(hex) {
  if (!hex) return null;
  const m = hex.replace('#', '');
  const bigint = parseInt(m, 16);
  return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
}

function rgbToHsl(r, g, b) {
  r /= 255; g /= 255; b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;
  if (max === min) { h = s = 0; } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }
  return [h * 360, s, l];
}

function hslToRgb(h, s, l) {
  h /= 360;
  let r, g, b;
  if (s === 0) { r = g = b = l; } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1; if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function lerpVal(a, b, t) { return a + (b - a) * t; }
function lerp(a, b, t) { return a + (b - a) * t; }
function lerpColor(c1, c2, t) {
  if (!c1) return c2 ? c2.slice() : null;
  if (!c2) return c1.slice();
  return [
    Math.round(lerpVal(c1[0], c2[0], t)),
    Math.round(lerpVal(c1[1], c2[1], t)),
    Math.round(lerpVal(c1[2], c2[2], t)),
  ];
}

// ─── Render orbs & display params ───────────────────────────────────────────
let renderOrbs = baseOrbs.map(b => ({ ...b }));
let displayParams = { ...params };
let displayColorA = null;
let displayColorB = null;
let appliedParticleCount = baseOrbs.length;
let pendingParticleCount = appliedParticleCount;
let particleCountTimer = null;
const PARTICLE_COUNT_DEBOUNCE = 200;

let time = 0;

// ─── Draw loop ───────────────────────────────────────────────────────────────
function draw() {
  // speed contrôle l'incrément de temps (avant : time++ fixe)
  time += speed;

  mouse.x = lerp(mouse.x, target.x, 0.04);
  mouse.y = lerp(mouse.y, target.y, 0.04);

  // Régénération des orbes si particleCount change
  if (renderOrbs.length !== appliedParticleCount) {
    const next = [];
    for (let i = 0; i < appliedParticleCount; i++) {
      const b = baseOrbs[i % baseOrbs.length];
      next.push({
        x: b.x + (Math.random() - 0.5) * 0.08,
        y: b.y + (Math.random() - 0.5) * 0.08,
        phase: b.phase + Math.random() * 6.28,
        baseIndex: i % baseOrbs.length,
      });
    }
    renderOrbs = next;
  }

  // Lerp des displayParams vers les targets
  const LERP_FACTOR = 0.22;
  displayParams.speed        = lerpVal(displayParams.speed,        clamp(Number(params.speed        || 1), 0.1, 5),    LERP_FACTOR);
  displayParams.intensity    = lerpVal(displayParams.intensity,    clamp(Number(params.intensity    || 1), 0,   3),    LERP_FACTOR);
  displayParams.particleSize = lerpVal(displayParams.particleSize, clamp(Number(params.particleSize || 1), 0.2, 3),    LERP_FACTOR);
  displayParams.offsetY      = lerpVal(displayParams.offsetY,      clamp(Number(params.offsetY      || 0), -0.5, 0.5), LERP_FACTOR);
  displayParams.hueShift     = lerpVal(displayParams.hueShift,     clamp(Number(params.hueShift     || 0), 0, 360),    LERP_FACTOR);
  displayParams.enableGlow   = params.enableGlow !== false;

  if (params.colorA) displayColorA = lerpColor(displayColorA, hexToRgb(String(params.colorA)), LERP_FACTOR) || displayColorA;
  if (params.colorB) displayColorB = lerpColor(displayColorB, hexToRgb(String(params.colorB)), LERP_FACTOR) || displayColorB;

  // trail contrôle la persistence (avant : 0.18 fixe)
  ctx.fillStyle = `rgba(4,4,10,${trail})`;
  ctx.fillRect(0, 0, W, H);

  const sizeFactor  = displayParams.particleSize;
  const speedFactor = displayParams.speed;
  const enableGlow  = displayParams.enableGlow;

  for (let i = 0; i < renderOrbs.length; i++) {
    const inst = renderOrbs[i];
    const base = baseOrbs[inst.baseIndex !== undefined ? inst.baseIndex : i % baseOrbs.length];

    const orbSpeed = (base.speed || 0.0008) * speedFactor;
    const drift    = Math.sin(time * orbSpeed * 1000 + inst.phase) * 0.12;
    const driftY   = Math.cos(time * orbSpeed * 800  + inst.phase) * 0.10;

    // mouseInfluence remplace la valeur hardcodée 0.18
    const mx = (mouse.x - 0.5) * mouseInfluence * (i % 2 === 0 ?  1 : -1);
    const my = (mouse.y - 0.5) * (mouseInfluence * 0.78) * (i % 2 === 0 ? -1 :  1);

    const cx     = (inst.x + drift  + mx) * W;
    const cy     = (inst.y + driftY + my + (displayParams.offsetY || 0)) * H;
    const radius = base.r * Math.min(W, H) * sizeFactor;

    // Couleur de l'orbe
    let color = (base.color && base.color.slice()) || [200, 200, 200];
    if (displayColorA && i % 2 === 0) color = displayColorA;
    if (displayColorB && i % 2 === 1) color = displayColorB;
    if (displayParams.hueShift) {
      const [h, s, l] = rgbToHsl(color[0], color[1], color[2]);
      color = hslToRgb((h + displayParams.hueShift + 360) % 360, s, l);
    }

    const [r, g, b] = color;
    // intensity multiplie l'alpha (avant : pas de multiplicateur)
    const alpha = (0.13 + Math.sin(time * 0.02 + inst.phase) * 0.04)
                  * (enableGlow ? intensity : 0.0001);

    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
    grad.addColorStop(0,   `rgba(${r},${g},${b},${alpha})`);
    grad.addColorStop(0.5, `rgba(${r},${g},${b},${alpha * 0.4})`);
    grad.addColorStop(1,   `rgba(${r},${g},${b},0)`);

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(cx, cy, radius * 1.2, radius * 0.8, time * 0.001 + inst.phase, 0, Math.PI * 2);
    ctx.fill();
  }

  requestAnimationFrame(draw);
}
draw();

// ─── Listener postMessage ─────────────────────────────────────────────────────
// Flux : Slider React → setLocal → useEffect → postMessage → ici → draw() lit la variable
window.addEventListener('message', (ev) => {
  try {
    const msg = ev.data;
    if (!msg || msg.type !== 'params:update') return;
    const p = msg.params || {};

    // ── Variables directes (lues chaque frame par draw) ──────────────────────
    if (p.speed          !== undefined) speed          = clamp(Number(p.speed),          0.1, 5);
    if (p.trail          !== undefined) trail          = clamp(Number(p.trail),           0.01, 1);
    if (p.intensity      !== undefined) intensity      = clamp(Number(p.intensity),       0, 3);
    if (p.mouseInfluence !== undefined) mouseInfluence = clamp(Number(p.mouseInfluence),  0, 1);

    // ── Params avec lerp (smooth) ─────────────────────────────────────────────
    if ('speed'        in p) params.speed        = clamp(Number(p.speed        || 1), 0.1, 5);
    if ('intensity'    in p) params.intensity    = clamp(Number(p.intensity    || 0), 0, 3);
    if ('particleSize' in p) params.particleSize = clamp(Number(p.particleSize || 1), 0.2, 3);
    if ('offsetY'      in p) params.offsetY      = clamp(Number(p.offsetY      || 0), -0.5, 0.5);
    if ('hueShift'     in p) params.hueShift     = clamp(Number(p.hueShift     || 0), 0, 360);
    if ('enableGlow'   in p) params.enableGlow   = !!p.enableGlow;

    // Couleurs hex → params (le lerp se fait dans draw)
    if ('colorA' in p) {
      const v = String(p.colorA || '');
      if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(v)) {
        params.colorA = v;
        // Mise à jour directe de la couleur de l'orbe 0 (index pair)
        const rgb = hexToRgb(v); if (rgb) baseOrbs[0].color = rgb;
      }
    }
    if ('colorB' in p) {
      const v = String(p.colorB || '');
      if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(v)) {
        params.colorB = v;
        // Mise à jour directe de la couleur de l'orbe 1 (index impair)
        const rgb = hexToRgb(v); if (rgb) baseOrbs[1].color = rgb;
      }
    }
    if ('colorC' in p) {
      const v = String(p.colorC || '');
      if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(v)) {
        const rgb = hexToRgb(v); if (rgb) baseOrbs[2].color = rgb;
      }
    }

    // particleCount avec debounce (régénération coûteuse)
    if ('particleCount' in p) {
      const requested = Math.max(1, Math.min(2000, Math.floor(Number(p.particleCount) || baseOrbs.length)));
      pendingParticleCount = requested;
      if (particleCountTimer) clearTimeout(particleCountTimer);
      particleCountTimer = setTimeout(() => {
        appliedParticleCount = pendingParticleCount;
        params.particleCount = appliedParticleCount;
        particleCountTimer = null;
      }, PARTICLE_COUNT_DEBOUNCE);
    }

  } catch (e) {
    // ignore malformed messages
  }
}, false);
</script>
</body>
</html>