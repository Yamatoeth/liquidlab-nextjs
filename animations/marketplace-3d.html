<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NEXUS — Marketplace 3D</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600&display=swap');

  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --cyan: #00f5ff;
    --blue: #0066ff;
    --neon: #00ffcc;
    --dark: #010814;
    --mid: #050e2a;
    --glass: rgba(0, 245, 255, 0.05);
    --border: rgba(0, 245, 255, 0.15);
  }

  html, body {
    width: 100%; height: 100%;
    background: var(--dark);
    overflow: hidden;
    cursor: none;
    font-family: 'Rajdhani', sans-serif;
  }

  #canvas-container {
    position: fixed; inset: 0;
    z-index: 0;
  }

  canvas { display: block; }

  /* Custom cursor */
  #cursor {
    position: fixed;
    width: 12px; height: 12px;
    background: var(--cyan);
    border-radius: 50%;
    pointer-events: none;
    z-index: 9999;
    transform: translate(-50%, -50%);
    transition: width 0.2s, height 0.2s, opacity 0.2s;
    box-shadow: 0 0 15px var(--cyan), 0 0 30px var(--cyan);
    mix-blend-mode: screen;
  }
  #cursor-ring {
    position: fixed;
    width: 40px; height: 40px;
    border: 1px solid rgba(0, 245, 255, 0.5);
    border-radius: 50%;
    pointer-events: none;
    z-index: 9998;
    transform: translate(-50%, -50%);
    transition: width 0.4s ease, height 0.4s ease, transform 0.15s ease;
  }

  /* UI Overlay */
  #ui {
    position: fixed; inset: 0;
    z-index: 10;
    pointer-events: none;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 40px 50px;
  }

  /* Header */
  .header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
  }

  .logo {
    font-family: 'Orbitron', monospace;
    font-weight: 900;
    font-size: 28px;
    letter-spacing: 8px;
    color: #fff;
    text-shadow: 0 0 20px var(--cyan), 0 0 60px rgba(0,245,255,0.3);
    animation: logoGlow 3s ease-in-out infinite alternate;
  }

  @keyframes logoGlow {
    from { text-shadow: 0 0 20px var(--cyan), 0 0 40px rgba(0,245,255,0.3); }
    to   { text-shadow: 0 0 30px var(--cyan), 0 0 80px rgba(0,245,255,0.5), 0 0 120px rgba(0,245,255,0.2); }
  }

  .status-bar {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 6px;
  }

  .status-item {
    font-family: 'Rajdhani', sans-serif;
    font-size: 11px;
    letter-spacing: 3px;
    color: rgba(0, 245, 255, 0.6);
    text-transform: uppercase;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .dot {
    width: 6px; height: 6px;
    background: var(--neon);
    border-radius: 50%;
    animation: blink 1.5s ease-in-out infinite;
    box-shadow: 0 0 8px var(--neon);
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.2; }
  }

  /* Center content */
  .center-content {
    position: absolute;
    top: 50%;
    left: 50px;
    transform: translateY(-50%);
    max-width: 480px;
  }

  .eyebrow {
    font-size: 11px;
    letter-spacing: 5px;
    color: var(--cyan);
    text-transform: uppercase;
    margin-bottom: 20px;
    opacity: 0;
    animation: fadeUp 0.8s ease 0.3s forwards;
  }

  .headline {
    font-family: 'Orbitron', monospace;
    font-size: clamp(36px, 5vw, 64px);
    font-weight: 900;
    line-height: 1.05;
    color: #fff;
    margin-bottom: 24px;
    opacity: 0;
    animation: fadeUp 0.8s ease 0.5s forwards;
  }

  .headline span {
    background: linear-gradient(135deg, var(--cyan), var(--blue), var(--neon));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .subtext {
    font-size: 16px;
    line-height: 1.7;
    color: rgba(255,255,255,0.5);
    margin-bottom: 40px;
    font-weight: 300;
    letter-spacing: 0.5px;
    opacity: 0;
    animation: fadeUp 0.8s ease 0.7s forwards;
  }

  .cta-group {
    display: flex;
    gap: 16px;
    pointer-events: all;
    opacity: 0;
    animation: fadeUp 0.8s ease 0.9s forwards;
  }

  .btn-primary {
    padding: 14px 32px;
    background: transparent;
    border: 1px solid var(--cyan);
    color: var(--cyan);
    font-family: 'Orbitron', monospace;
    font-size: 11px;
    letter-spacing: 4px;
    text-transform: uppercase;
    cursor: none;
    position: relative;
    overflow: hidden;
    transition: color 0.3s;
  }

  .btn-primary::before {
    content: '';
    position: absolute;
    inset: 0;
    background: var(--cyan);
    transform: translateX(-101%);
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: -1;
  }

  .btn-primary:hover::before { transform: translateX(0); }
  .btn-primary:hover { color: var(--dark); }

  .btn-secondary {
    padding: 14px 32px;
    background: transparent;
    border: 1px solid rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.4);
    font-family: 'Orbitron', monospace;
    font-size: 11px;
    letter-spacing: 4px;
    text-transform: uppercase;
    cursor: none;
    transition: border-color 0.3s, color 0.3s;
  }

  .btn-secondary:hover {
    border-color: rgba(255,255,255,0.3);
    color: rgba(255,255,255,0.7);
  }

  /* Bottom bar */
  .bottom-bar {
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
  }

  .stats {
    display: flex;
    gap: 48px;
  }

  .stat {
    opacity: 0;
    animation: fadeUp 0.8s ease 1.2s forwards;
  }

  .stat-num {
    font-family: 'Orbitron', monospace;
    font-size: 28px;
    font-weight: 700;
    color: #fff;
    letter-spacing: 2px;
    line-height: 1;
  }

  .stat-num span { color: var(--cyan); }

  .stat-label {
    font-size: 10px;
    letter-spacing: 3px;
    color: rgba(255,255,255,0.3);
    text-transform: uppercase;
    margin-top: 4px;
  }

  .hint {
    font-size: 10px;
    letter-spacing: 3px;
    color: rgba(0, 245, 255, 0.3);
    text-transform: uppercase;
    animation: pulseOpacity 2s ease-in-out infinite;
  }

  @keyframes pulseOpacity {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.8; }
  }

  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(20px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  /* Scanlines overlay */
  #scanlines {
    position: fixed; inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.03) 2px,
      rgba(0, 0, 0, 0.03) 4px
    );
    pointer-events: none;
    z-index: 5;
  }

  /* Corner decorations */
  .corner {
    position: fixed;
    width: 60px; height: 60px;
    pointer-events: none;
    z-index: 15;
  }
  .corner::before, .corner::after {
    content: '';
    position: absolute;
    background: var(--cyan);
  }
  .corner::before { width: 100%; height: 1px; }
  .corner::after  { width: 1px; height: 100%; }

  .corner-tl { top: 24px; left: 24px; }
  .corner-tr { top: 24px; right: 24px; transform: scaleX(-1); }
  .corner-bl { bottom: 24px; left: 24px; transform: scaleY(-1); }
  .corner-br { bottom: 24px; right: 24px; transform: scale(-1); }

  /* Tooltip */
  #tooltip {
    position: fixed;
    background: rgba(0, 10, 30, 0.9);
    border: 1px solid var(--border);
    padding: 10px 16px;
    font-size: 11px;
    letter-spacing: 2px;
    color: var(--cyan);
    text-transform: uppercase;
    pointer-events: none;
    z-index: 100;
    opacity: 0;
    transition: opacity 0.3s;
    font-family: 'Rajdhani', sans-serif;
    backdrop-filter: blur(10px);
  }
</style>
</head>
<body>

<div id="cursor"></div>
<div id="cursor-ring"></div>
<div id="scanlines"></div>
<div id="tooltip"></div>

<!-- Corner decorations -->
<div class="corner corner-tl"></div>
<div class="corner corner-tr"></div>
<div class="corner corner-bl"></div>
<div class="corner corner-br"></div>

<div id="canvas-container"></div>

<div id="ui">
  <div class="header">
    <div class="logo">NEXUS</div>
    <div class="status-bar">
      <div class="status-item"><div class="dot"></div> SYSTÈME EN LIGNE</div>
      <div class="status-item"><div class="dot" style="animation-delay:0.5s"></div> RÉSEAU SÉCURISÉ</div>
      <div class="status-item" id="fps-counter">00 FPS</div>
    </div>
  </div>

  <div class="center-content">
    <div class="eyebrow">// Marketplace du futur — v2.0.24</div>
    <h1 class="headline">La nouvelle<br>ère du<br><span>commerce</span></h1>
    <p class="subtext">Une plateforme d'échange immersive construite pour le monde de demain. Interagissez, explorez, échangez dans un univers tridimensionnel.</p>
    <div class="cta-group">
      <button class="btn-primary">Entrer</button>
      <button class="btn-secondary">Explorer</button>
    </div>
  </div>

  <div class="bottom-bar">
    <div class="stats">
      <div class="stat">
        <div class="stat-num">12<span>K</span></div>
        <div class="stat-label">Vendeurs actifs</div>
      </div>
      <div class="stat" style="animation-delay:1.35s">
        <div class="stat-num">98<span>%</span></div>
        <div class="stat-label">Satisfaction</div>
      </div>
      <div class="stat" style="animation-delay:1.5s">
        <div class="stat-num">4<span>M</span></div>
        <div class="stat-label">Transactions</div>
      </div>
    </div>
    <div class="hint">← Glissez pour explorer →</div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ==================== SETUP ====================
const container = document.getElementById('canvas-container');
const W = window.innerWidth, H = window.innerHeight;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(W, H);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x010814);
scene.fog = new THREE.FogExp2(0x010814, 0.035);

const camera = new THREE.PerspectiveCamera(60, W / H, 0.1, 200);
camera.position.set(0, 2, 14);

// ==================== MOUSE ====================
const mouse = { x: 0, y: 0, px: 0, py: 0 };
const cursor = document.getElementById('cursor');
const ring = document.getElementById('cursor-ring');
const tooltip = document.getElementById('tooltip');

document.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / W) * 2 - 1;
  mouse.y = -(e.clientY / H) * 2 + 1;
  cursor.style.left = e.clientX + 'px';
  cursor.style.top  = e.clientY + 'px';
  ring.style.left   = e.clientX + 'px';
  ring.style.top    = e.clientY + 'px';
  tooltip.style.left = (e.clientX + 20) + 'px';
  tooltip.style.top  = (e.clientY - 10) + 'px';
});

// ==================== GRID FLOOR ====================
const gridHelper = new THREE.GridHelper(80, 60, 0x001133, 0x001133);
gridHelper.position.y = -4;
gridHelper.material.opacity = 0.6;
gridHelper.material.transparent = true;
scene.add(gridHelper);

// Glowing horizon line
const horizonGeo = new THREE.PlaneGeometry(200, 0.03);
const horizonMat = new THREE.MeshBasicMaterial({
  color: 0x00f5ff, transparent: true, opacity: 0.4
});
const horizon = new THREE.Mesh(horizonGeo, horizonMat);
horizon.rotation.x = -Math.PI / 2;
horizon.position.y = -4.01;
scene.add(horizon);

// ==================== CENTRAL TORUS KNOT ====================
const knotGeo = new THREE.TorusKnotGeometry(2.2, 0.45, 200, 32, 2, 3);
const knotMat = new THREE.MeshStandardMaterial({
  color: 0x001040,
  emissive: 0x003366,
  emissiveIntensity: 0.4,
  metalness: 0.9,
  roughness: 0.1,
  wireframe: false,
});
const knot = new THREE.Mesh(knotGeo, knotMat);
scene.add(knot);

// Wireframe overlay on knot
const knotWireGeo = new THREE.TorusKnotGeometry(2.25, 0.46, 80, 16, 2, 3);
const knotWireMat = new THREE.MeshBasicMaterial({
  color: 0x00f5ff, wireframe: true, transparent: true, opacity: 0.08
});
const knotWire = new THREE.Mesh(knotWireGeo, knotWireMat);
scene.add(knotWire);

// ==================== ORBITING RINGS ====================
function createRing(innerR, outerR, color, rotX, rotZ, opacity = 0.6) {
  const geo = new THREE.RingGeometry(innerR, outerR, 128);
  const mat = new THREE.MeshBasicMaterial({
    color, side: THREE.DoubleSide, transparent: true, opacity
  });
  const ring = new THREE.Mesh(geo, mat);
  ring.rotation.x = rotX;
  ring.rotation.z = rotZ;
  scene.add(ring);
  return ring;
}

const ring1 = createRing(3.2, 3.25, 0x00f5ff, Math.PI / 3, 0.3, 0.5);
const ring2 = createRing(3.8, 3.83, 0x0066ff, Math.PI / 2.5, -0.5, 0.3);
const ring3 = createRing(4.5, 4.52, 0x00ffcc, Math.PI / 1.8, 0.8, 0.2);

// ==================== FLOATING CUBES ====================
const cubeGroup = new THREE.Group();
scene.add(cubeGroup);

const cubeColors = [0x00f5ff, 0x0066ff, 0x00ffcc, 0x004499, 0x0099ff];
const cubes = [];

for (let i = 0; i < 22; i++) {
  const s = 0.12 + Math.random() * 0.3;
  const geo = Math.random() > 0.5
    ? new THREE.BoxGeometry(s, s, s)
    : new THREE.OctahedronGeometry(s * 0.8);
  const mat = new THREE.MeshStandardMaterial({
    color: cubeColors[Math.floor(Math.random() * cubeColors.length)],
    metalness: 1, roughness: 0.1,
    emissive: cubeColors[Math.floor(Math.random() * cubeColors.length)],
    emissiveIntensity: 0.3,
  });
  const mesh = new THREE.Mesh(geo, mat);
  const radius = 5.5 + Math.random() * 3;
  const theta = (i / 22) * Math.PI * 2 + Math.random() * 0.5;
  const phi = (Math.random() - 0.5) * Math.PI;
  mesh.position.set(
    radius * Math.cos(theta) * Math.cos(phi),
    radius * Math.sin(phi) * 0.6,
    radius * Math.sin(theta) * Math.cos(phi)
  );
  mesh.userData = {
    basePos: mesh.position.clone(),
    speed: 0.3 + Math.random() * 0.7,
    offset: Math.random() * Math.PI * 2,
    rotSpeed: (Math.random() - 0.5) * 0.03,
  };
  cubeGroup.add(mesh);
  cubes.push(mesh);
}

// ==================== PARTICLES ====================
const particleCount = 2000;
const positions = new Float32Array(particleCount * 3);
const particleColors = new Float32Array(particleCount * 3);
const particleSizes = new Float32Array(particleCount);

for (let i = 0; i < particleCount; i++) {
  const i3 = i * 3;
  const r = 8 + Math.random() * 30;
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(2 * Math.random() - 1);

  positions[i3]     = r * Math.sin(phi) * Math.cos(theta);
  positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta) * 0.4;
  positions[i3 + 2] = r * Math.cos(phi);

  const t = Math.random();
  particleColors[i3]     = t < 0.33 ? 0 : t < 0.66 ? 0 : 1;
  particleColors[i3 + 1] = t < 0.33 ? 0.96 : t < 0.66 ? 0.4 : 1;
  particleColors[i3 + 2] = t < 0.33 ? 1 : t < 0.66 ? 1 : 0.8;

  particleSizes[i] = 0.5 + Math.random() * 2;
}

const particleGeo = new THREE.BufferGeometry();
particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
particleGeo.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));

const particleMat = new THREE.PointsMaterial({
  size: 0.06,
  vertexColors: true,
  transparent: true,
  opacity: 0.7,
  sizeAttenuation: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
});
const particles = new THREE.Points(particleGeo, particleMat);
scene.add(particles);

// ==================== DATA STREAMS ====================
const streamGroup = new THREE.Group();
scene.add(streamGroup);

for (let s = 0; s < 8; s++) {
  const points = [];
  const startX = (Math.random() - 0.5) * 20;
  const startZ = (Math.random() - 0.5) * 20;
  for (let p = 0; p < 12; p++) {
    points.push(new THREE.Vector3(
      startX + (Math.random() - 0.5) * 2,
      -4 + p * 1.2,
      startZ + (Math.random() - 0.5) * 2
    ));
  }
  const curve = new THREE.CatmullRomCurve3(points);
  const tubeGeo = new THREE.TubeGeometry(curve, 30, 0.008, 4, false);
  const tubeMat = new THREE.MeshBasicMaterial({
    color: Math.random() > 0.5 ? 0x00f5ff : 0x0066ff,
    transparent: true,
    opacity: 0.15 + Math.random() * 0.2,
  });
  streamGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
}

// ==================== LIGHTS ====================
scene.add(new THREE.AmbientLight(0x001033, 2));

const pointCyan = new THREE.PointLight(0x00f5ff, 3, 20);
pointCyan.position.set(4, 4, 4);
scene.add(pointCyan);

const pointBlue = new THREE.PointLight(0x0066ff, 2, 20);
pointBlue.position.set(-4, -2, -4);
scene.add(pointBlue);

const pointNeon = new THREE.PointLight(0x00ffcc, 1.5, 15);
pointNeon.position.set(0, 6, 0);
scene.add(pointNeon);

// Rim light from behind
const rimLight = new THREE.DirectionalLight(0x001155, 1);
rimLight.position.set(-10, 5, -10);
scene.add(rimLight);

// ==================== RAYCASTER ====================
const raycaster = new THREE.Raycaster();
const interactiveObjects = cubes;
let hoveredObj = null;

// ==================== ANIMATION ====================
let t = 0;
let fps = 60;
let lastTime = performance.now();
let frameCount = 0;
const fpsEl = document.getElementById('fps-counter');

function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  t += dt;
  frameCount++;
  if (frameCount % 30 === 0) fpsEl.textContent = Math.round(1 / dt) + ' FPS';

  // Camera parallax
  const targetX = mouse.x * 1.5;
  const targetY = 2 + mouse.y * 0.8;
  camera.position.x += (targetX - camera.position.x) * 0.04;
  camera.position.y += (targetY - camera.position.y) * 0.04;
  camera.lookAt(0, 0, 0);

  // Knot rotation
  knot.rotation.x = t * 0.18;
  knot.rotation.y = t * 0.25;
  knotWire.rotation.x = t * 0.18;
  knotWire.rotation.y = t * 0.25;

  // Rings
  ring1.rotation.z = t * 0.3;
  ring2.rotation.z = -t * 0.2;
  ring3.rotation.z = t * 0.15;
  ring1.rotation.y = t * 0.1;

  // Cubes orbit + float
  cubeGroup.rotation.y = t * 0.05;
  cubes.forEach(c => {
    const { offset, speed, rotSpeed } = c.userData;
    c.position.y = c.userData.basePos.y + Math.sin(t * speed + offset) * 0.4;
    c.rotation.x += rotSpeed;
    c.rotation.y += rotSpeed * 0.7;
  });

  // Particles slow spin
  particles.rotation.y = t * 0.02;
  particles.rotation.x = Math.sin(t * 0.05) * 0.05;

  // Lights pulsing
  pointCyan.intensity = 3 + Math.sin(t * 2.1) * 0.8;
  pointBlue.intensity = 2 + Math.cos(t * 1.7) * 0.5;

  // Data streams flow
  streamGroup.children.forEach((s, i) => {
    s.material.opacity = 0.08 + 0.15 * Math.abs(Math.sin(t * 0.8 + i));
  });

  // Raycaster hover
  raycaster.setFromCamera({ x: mouse.x, y: mouse.y }, camera);
  const hits = raycaster.intersectObjects(interactiveObjects);

  if (hits.length > 0 && hits[0].distance < 12) {
    const obj = hits[0].object;
    if (hoveredObj !== obj) {
      if (hoveredObj) {
        hoveredObj.material.emissiveIntensity = 0.3;
        hoveredObj.scale.setScalar(1);
      }
      hoveredObj = obj;
      hoveredObj.material.emissiveIntensity = 1.2;
      hoveredObj.scale.setScalar(1.5);
      tooltip.style.opacity = '1';
      tooltip.textContent = '+ ITEM #' + (Math.floor(Math.random() * 9000) + 1000);
    }
    document.body.style.cursor = 'none';
  } else {
    if (hoveredObj) {
      hoveredObj.material.emissiveIntensity = 0.3;
      hoveredObj.scale.setScalar(1);
      hoveredObj = null;
      tooltip.style.opacity = '0';
    }
  }

  renderer.render(scene, camera);
}

animate();

// ==================== RESIZE ====================
window.addEventListener('resize', () => {
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});

// ==================== SCROLL ====================
let scrollY = 0;
window.addEventListener('wheel', (e) => {
  scrollY += e.deltaY * 0.003;
  camera.position.z = 14 - scrollY * 0.5;
  camera.position.z = Math.max(5, Math.min(20, camera.position.z));
});

// ==================== CLICK RIPPLE ====================
document.addEventListener('click', (e) => {
  const ripple = document.createElement('div');
  Object.assign(ripple.style, {
    position: 'fixed',
    left: e.clientX + 'px', top: e.clientY + 'px',
    width: '4px', height: '4px',
    border: '1px solid rgba(0,245,255,0.8)',
    borderRadius: '50%',
    transform: 'translate(-50%, -50%)',
    pointerEvents: 'none',
    zIndex: '9990',
    animation: 'rippleOut 0.6s ease forwards',
  });
  document.body.appendChild(ripple);
  setTimeout(() => ripple.remove(), 600);
});

// Inject ripple keyframe
const style = document.createElement('style');
style.textContent = `@keyframes rippleOut {
  from { width:4px; height:4px; opacity:1; }
  to   { width:80px; height:80px; opacity:0; }
}`;
document.head.appendChild(style);
</script>
</body>
</html>
