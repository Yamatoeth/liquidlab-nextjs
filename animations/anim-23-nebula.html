<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nebula — FORMA</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;1,300;1,400&family=DM+Mono:wght@300&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; width: 100vw; height: 100vh; overflow: hidden; cursor: none; }

  canvas { position: fixed; inset: 0; }
  #c0 { z-index: 0; } /* deep stars */
  #c1 { z-index: 1; } /* nebula volumes */
  #c2 { z-index: 2; } /* particles + stars */
  #c3 { z-index: 3; } /* foreground glow */

  .ui { position: fixed; inset: 0; pointer-events: none; z-index: 20; }

  .watermark {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    opacity: 0;
    animation: fadeIn 3s ease 1.5s forwards;
  }
  @keyframes fadeIn { to { opacity: 1; } }

  .wm-title {
    font-family: 'Cormorant Garamond', serif;
    font-style: italic;
    font-size: clamp(36px, 6vw, 72px);
    font-weight: 300;
    color: rgba(255,255,255,0.07);
    letter-spacing: 0.25em;
    text-transform: uppercase;
    white-space: nowrap;
  }
  .wm-sub {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: rgba(255,255,255,0.04);
    letter-spacing: 0.5em;
    text-transform: uppercase;
    margin-top: 12px;
  }

  .corner {
    position: absolute;
    font-family: 'DM Mono', monospace;
    font-size: 9px; letter-spacing: 0.18em;
    color: rgba(255,255,255,0.14);
    text-transform: uppercase;
    line-height: 2;
    animation: fadeIn 2s ease 2s forwards;
    opacity: 0;
  }
  .tl { top: 28px; left: 32px; }
  .tr { top: 28px; right: 32px; text-align: right; }
  .bl { bottom: 28px; left: 32px; }
  .br { bottom: 28px; right: 32px; text-align: right; }

  #cursor {
    position: fixed; pointer-events: none; z-index: 100;
    width: 2px; height: 2px;
    background: rgba(255,255,255,0.8);
    border-radius: 50%;
    transform: translate(-50%,-50%);
    box-shadow: 0 0 6px 2px rgba(255,255,255,0.3);
  }
</style>
</head>
<body>

<canvas id="c0"></canvas>
<canvas id="c1"></canvas>
<canvas id="c2"></canvas>
<canvas id="c3"></canvas>

<div class="ui">
  <div class="watermark">
    <div class="wm-title">Nebula</div>
    <div class="wm-sub">A universe in motion</div>
  </div>
  <div class="corner tl">NGC–2244 · Rosette<br><span id="starCount">0</span> stellar bodies</div>
  <div class="corner tr">T + <span id="elapsed">00:00</span><br>Δv = <span id="dv">0.00</span> pc/yr</div>
  <div class="corner bl">Move to sculpt · Click to collapse</div>
  <div class="corner br">Simulation · Real-time<br>FORMA · 2025</div>
</div>
<div id="cursor"></div>

<script>
// ═══════════════════════════════════════════════════════
//  CANVAS SETUP
// ═══════════════════════════════════════════════════════
const layers = ['c0','c1','c2','c3'].map(id => {
  const c = document.getElementById(id);
  return { c, ctx: c.getContext('2d') };
});
let W, H, cx, cy;
const cursorEl = document.getElementById('cursor');

function resize() {
  W = window.innerWidth; H = window.innerHeight;
  cx = W/2; cy = H/2;
  layers.forEach(l => { l.c.width = W; l.c.height = H; });
}
resize();
window.addEventListener('resize', () => { resize(); initDeepStars(); });

// ═══════════════════════════════════════════════════════
//  MOUSE
// ═══════════════════════════════════════════════════════
const mouse = { x: cx, y: cy, sx: cx, sy: cy, vx: 0, vy: 0, px: cx, py: cy, down: false };
window.addEventListener('mousemove', e => {
  mouse.px = mouse.x; mouse.py = mouse.y;
  mouse.x = e.clientX; mouse.y = e.clientY;
  mouse.vx = mouse.x - mouse.px; mouse.vy = mouse.y - mouse.py;
  cursorEl.style.left = e.clientX + 'px';
  cursorEl.style.top  = e.clientY + 'px';
});
window.addEventListener('mousedown', () => mouse.down = true);
window.addEventListener('mouseup',   () => mouse.down = false);
window.addEventListener('touchmove', e => {
  mouse.px=mouse.x; mouse.py=mouse.y;
  mouse.x=e.touches[0].clientX; mouse.y=e.touches[0].clientY;
  mouse.vx=mouse.x-mouse.px; mouse.vy=mouse.y-mouse.py;
  cursorEl.style.left=mouse.x+'px'; cursorEl.style.top=mouse.y+'px';
}, {passive:true});
window.addEventListener('touchstart', e => { mouse.down=true; mouse.x=e.touches[0].clientX; mouse.y=e.touches[0].clientY; },{passive:true});
window.addEventListener('touchend', () => mouse.down=false);

// ═══════════════════════════════════════════════════════
//  MATH
// ═══════════════════════════════════════════════════════
const lerp = (a,b,t) => a+(b-a)*t;
const clamp = (v,a,b) => Math.max(a,Math.min(b,v));
const rand = (a,b) => a + Math.random()*(b-a);
const randInt = (a,b) => Math.floor(rand(a,b));

// Smooth noise via layered sines
function noise2(x, y, t=0) {
  return (
    Math.sin(x*0.007 + t*0.2)  * Math.cos(y*0.009 - t*0.15) * 0.35 +
    Math.sin(x*0.013 - t*0.3)  * Math.cos(y*0.011 + t*0.25) * 0.25 +
    Math.sin(x*0.003 + y*0.004 + t*0.1) * 0.25 +
    Math.cos(x*0.018 - y*0.006 - t*0.18) * 0.15
  );
}

// ═══════════════════════════════════════════════════════
//  LAYER 0 — DEEP STAR FIELD (static, painted once)
// ═══════════════════════════════════════════════════════
function initDeepStars() {
  const ctx = layers[0].ctx;
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);

  // 3 populations: distant (tiny), mid, bright
  const pops = [
    { n: 800, rMin: 0.2, rMax: 0.5,  aMin: 0.05, aMax: 0.25, color: [200,210,255] },
    { n: 300, rMin: 0.4, rMax: 0.9,  aMin: 0.08, aMax: 0.4,  color: [220,225,255] },
    { n: 80,  rMin: 0.8, rMax: 1.8,  aMin: 0.2,  aMax: 0.8,  color: [255,245,220] },
    { n: 20,  rMin: 1.5, rMax: 3.0,  aMin: 0.4,  aMax: 1.0,  color: [255,230,180] },
  ];

  pops.forEach(p => {
    for (let i = 0; i < p.n; i++) {
      const x = rand(0,W), y = rand(0,H);
      const r = rand(p.rMin, p.rMax);
      const a = rand(p.aMin, p.aMax);
      const [cr,cg,cb] = p.color;
      // Slight color variance
      const hr = cr + randInt(-20,20), hg = cg + randInt(-10,10), hb = cb + randInt(-15,15);
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fillStyle = `rgba(${clamp(hr,0,255)},${clamp(hg,0,255)},${clamp(hb,0,255)},${a})`;
      ctx.fill();
      // Diffraction spike on brightest
      if (r > 2) {
        ctx.strokeStyle = `rgba(${clamp(hr,0,255)},${clamp(hg,0,255)},${clamp(hb,0,255)},${a*0.3})`;
        ctx.lineWidth = 0.4;
        ctx.beginPath(); ctx.moveTo(x-r*4,y); ctx.lineTo(x+r*4,y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x,y-r*4); ctx.lineTo(x,y+r*4); ctx.stroke();
      }
    }
  });
}
initDeepStars();

// ═══════════════════════════════════════════════════════
//  NEBULA VOLUMES (painted each N frames on c1)
// ═══════════════════════════════════════════════════════
// Nebula is 6 overlapping gaussian "clouds" with distinct hues
const NEBULA_CLOUDS = [
  { x: 0.42, y: 0.38, rx: 0.32, ry: 0.22, hue: 320, sat: 70, bri: 30, alpha: 0.18, drift: [0.00012, 0.00008] },
  { x: 0.58, y: 0.55, rx: 0.28, ry: 0.26, hue: 200, sat: 80, bri: 28, alpha: 0.14, drift: [-0.0001, 0.00006] },
  { x: 0.50, y: 0.48, rx: 0.20, ry: 0.18, hue: 260, sat: 60, bri: 35, alpha: 0.22, drift: [0.00005,-0.00009] },
  { x: 0.35, y: 0.60, rx: 0.22, ry: 0.16, hue: 180, sat: 75, bri: 25, alpha: 0.12, drift: [0.00009, 0.00011] },
  { x: 0.65, y: 0.35, rx: 0.18, ry: 0.20, hue: 350, sat: 65, bri: 32, alpha: 0.16, drift: [-0.00007,-0.00005] },
  { x: 0.50, y: 0.50, rx: 0.12, ry: 0.10, hue: 50,  sat: 40, bri: 50, alpha: 0.10, drift: [0.00003, 0.00004] },
];

let nebulaTime = 0;

function paintNebula(t) {
  const ctx = layers[1].ctx;
  ctx.clearRect(0,0,W,H);

  NEBULA_CLOUDS.forEach((cloud, ci) => {
    // Slowly drift each cloud
    const ox = cloud.x + Math.sin(t * 0.0003 + ci * 1.2) * 0.04;
    const oy = cloud.y + Math.cos(t * 0.0004 + ci * 0.9) * 0.03;
    const bx = ox * W, by = oy * H;
    const rx = cloud.rx * W, ry = cloud.ry * H;

    // Noise-warped elliptical gradient — multiple passes
    const passes = 4;
    for (let p = 0; p < passes; p++) {
      const nAngle = (p / passes) * Math.PI * 2;
      const nOff = noise2(bx + Math.cos(nAngle)*80, by + Math.sin(nAngle)*80, t*0.001) * 60;
      const px = bx + Math.cos(nAngle) * nOff * 0.5;
      const py = by + Math.sin(nAngle) * nOff * 0.3;

      const hShift = cloud.hue + Math.sin(t*0.0008 + ci*0.7 + p) * 18;
      const sShift = cloud.sat + Math.sin(t*0.0012 + p*0.5) * 10;

      ctx.save();
      ctx.translate(px, py);
      ctx.scale(rx / Math.min(rx,ry), ry / Math.min(rx,ry));

      const gr = ctx.createRadialGradient(0,0,0, 0,0, Math.min(rx,ry) * (0.7 + p*0.1));
      const a  = cloud.alpha * (1 - p*0.18) * (0.8 + 0.2*Math.sin(t*0.0015+ci));
      gr.addColorStop(0,   `hsla(${hShift},${sShift}%,${cloud.bri}%,${a})`);
      gr.addColorStop(0.4, `hsla(${hShift+15},${sShift-10}%,${cloud.bri-8}%,${a*0.5})`);
      gr.addColorStop(1,   `hsla(${hShift+30},${sShift-20}%,${cloud.bri-15}%,0)`);

      ctx.fillStyle = gr;
      ctx.beginPath(); ctx.arc(0,0, Math.min(rx,ry), 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // Filamentary tendrils
    const numFilaments = 6 + ci * 2;
    for (let f = 0; f < numFilaments; f++) {
      const fa  = (f / numFilaments) * Math.PI * 2 + t * 0.0001 * (ci%2?1:-1);
      const len = (0.4 + Math.random()*0.4) * Math.max(rx,ry);
      const x1  = bx + Math.cos(fa) * rx * 0.2;
      const y1  = by + Math.sin(fa) * ry * 0.2;
      const cpx = bx + Math.cos(fa + 0.4) * rx * 0.6 + noise2(x1,y1,t*0.0005)*40;
      const cpy = by + Math.sin(fa + 0.4) * ry * 0.6 + noise2(y1,x1,t*0.0005)*30;
      const x2  = bx + Math.cos(fa + 0.8) * rx * 0.9;
      const y2  = by + Math.sin(fa + 0.8) * ry * 0.9;

      const fg = ctx.createLinearGradient(x1,y1,x2,y2);
      fg.addColorStop(0,   `hsla(${cloud.hue+20},${cloud.sat}%,${cloud.bri+5}%,${cloud.alpha*0.3})`);
      fg.addColorStop(0.5, `hsla(${cloud.hue},${cloud.sat-10}%,${cloud.bri}%,${cloud.alpha*0.15})`);
      fg.addColorStop(1,   `hsla(${cloud.hue},${cloud.sat}%,${cloud.bri}%,0)`);

      ctx.strokeStyle = fg;
      ctx.lineWidth = 0.6 + Math.random();
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.quadraticCurveTo(cpx,cpy,x2,y2); ctx.stroke();
    }
  });

  // Central ionization glow (OB star cluster core)
  const coreGrad = ctx.createRadialGradient(cx,cy,0,cx,cy,Math.min(W,H)*0.15);
  coreGrad.addColorStop(0,   `rgba(255,248,220,${0.06+0.02*Math.sin(t*0.002)})`);
  coreGrad.addColorStop(0.3, `rgba(180,200,255,0.04)`);
  coreGrad.addColorStop(0.7, `rgba(120,160,255,0.02)`);
  coreGrad.addColorStop(1,   'rgba(0,0,0,0)');
  ctx.fillStyle = coreGrad;
  ctx.beginPath(); ctx.arc(cx,cy,Math.min(W,H)*0.15,0,Math.PI*2); ctx.fill();
}

// ═══════════════════════════════════════════════════════
//  PARTICLES — STAR FORMATION + DUST
// ═══════════════════════════════════════════════════════
class Particle {
  constructor(type='dust') {
    this.type = type;
    this.reset(true);
  }

  reset(init=false) {
    const cloud = NEBULA_CLOUDS[randInt(0, NEBULA_CLOUDS.length)];
    this.x  = cloud.x*W + rand(-cloud.rx*W*0.6, cloud.rx*W*0.6);
    this.y  = cloud.y*H + rand(-cloud.ry*H*0.6, cloud.ry*H*0.6);
    if (init) { this.x = rand(0,W); this.y = rand(0,H); }
    this.vx = rand(-0.08, 0.08);
    this.vy = rand(-0.08, 0.08);
    this.life = rand(0.3, 1);
    this.maxLife = rand(200, 800);
    this.age  = init ? rand(0, this.maxLife) : 0;
    if (this.type === 'star') {
      this.r    = rand(0.5, 2.5);
      this.hue  = rand(180, 360);
      this.sat  = rand(40, 90);
      this.bri  = rand(70, 100);
      this.twinkle = rand(0.02, 0.08);
      this.twinklePhase = rand(0, Math.PI*2);
    } else {
      this.r    = rand(1, 4);
      this.hue  = NEBULA_CLOUDS[randInt(0,NEBULA_CLOUDS.length)].hue + rand(-20,20);
      this.alpha = rand(0.02, 0.12);
    }
  }

  update(t) {
    this.age++;
    // Nebula flow field
    const flow  = noise2(this.x, this.y, t*0.0003) * Math.PI * 2;
    this.vx += Math.cos(flow) * 0.006;
    this.vy += Math.sin(flow) * 0.006;

    // Mouse gravity / repulsion
    const dx = this.x - mouse.sx;
    const dy = this.y - mouse.sy;
    const d  = Math.hypot(dx,dy) + 1;
    if (mouse.down) {
      // Gravitational collapse
      if (d < 300) { this.vx -= (dx/d)*0.8; this.vy -= (dy/d)*0.8; }
    } else {
      // Gentle attraction
      if (d < 200) { this.vx -= (dx/d)*0.04; this.vy -= (dy/d)*0.04; }
    }

    // Velocity cap + damping
    const spd = Math.hypot(this.vx,this.vy);
    if (spd > 1.5) { this.vx = this.vx/spd*1.5; this.vy = this.vy/spd*1.5; }
    this.vx *= 0.995; this.vy *= 0.995;
    this.x  += this.vx; this.y  += this.vy;

    // Lifecycle
    const lifeT = this.age / this.maxLife;
    this.life = Math.sin(lifeT * Math.PI);

    if (this.age > this.maxLife || this.x<-50||this.x>W+50||this.y<-50||this.y>H+50) this.reset();
  }

  draw(ctx, t) {
    if (this.type === 'star') {
      const twinkle = 0.7 + 0.3*Math.sin(t*this.twinkle + this.twinklePhase);
      const a = this.life * twinkle;
      const r = this.r * twinkle;
      // Glow
      const gr = ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,r*5);
      gr.addColorStop(0,   `hsla(${this.hue},${this.sat}%,${this.bri}%,${a*0.6})`);
      gr.addColorStop(0.3, `hsla(${this.hue},${this.sat}%,${this.bri-20}%,${a*0.2})`);
      gr.addColorStop(1,   `hsla(${this.hue},${this.sat}%,${this.bri}%,0)`);
      ctx.fillStyle = gr;
      ctx.beginPath(); ctx.arc(this.x,this.y,r*5,0,Math.PI*2); ctx.fill();
      // Core
      ctx.beginPath(); ctx.arc(this.x,this.y,r,0,Math.PI*2);
      ctx.fillStyle = `hsla(${this.hue},20%,100%,${a})`; ctx.fill();
    } else {
      ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
      ctx.fillStyle = `hsla(${this.hue},50%,40%,${this.life*this.alpha})`;
      ctx.fill();
    }
  }
}

const STAR_COUNT = 280;
const DUST_COUNT = 600;
const particles = [
  ...Array.from({length: STAR_COUNT}, () => new Particle('star')),
  ...Array.from({length: DUST_COUNT}, () => new Particle('dust')),
];

// ═══════════════════════════════════════════════════════
//  N-BODY GRAVITY SOURCES (massive star cluster)
// ═══════════════════════════════════════════════════════
const BODIES = Array.from({length: 5}, (_, i) => {
  const a = (i/5)*Math.PI*2;
  return {
    x: cx + Math.cos(a)*Math.min(W,H)*0.12,
    y: cy + Math.sin(a)*Math.min(W,H)*0.12,
    mass: 80 + rand(0,120),
    vx: -Math.sin(a)*0.15,
    vy:  Math.cos(a)*0.15,
    hue: rand(40,80),
    r: rand(3,6),
    trail: [],
  };
});

function updateBodies(t) {
  BODIES.forEach((b, i) => {
    // Orbit attraction to center
    const dcx = cx - b.x, dcy = cy - b.y;
    const dc  = Math.hypot(dcx,dcy)+1;
    b.vx += (dcx/dc)*0.006;
    b.vy += (dcy/dc)*0.006;

    // Body-body gravity
    BODIES.forEach((other, j) => {
      if (i===j) return;
      const dx = other.x-b.x, dy = other.y-b.y;
      const d  = Math.hypot(dx,dy)+20;
      const f  = other.mass*0.00002/(d*d)*d;
      b.vx += (dx/d)*f; b.vy += (dy/d)*f;
    });

    // Mouse interaction
    const mdx = mouse.sx-b.x, mdy = mouse.sy-b.y;
    const md  = Math.hypot(mdx,mdy)+1;
    if (mouse.down && md < 300) {
      b.vx += (mdx/md)*0.3; b.vy += (mdy/md)*0.3;
    }

    b.vx *= 0.995; b.vy *= 0.995;
    b.x  += b.vx;  b.y  += b.vy;
    b.x = clamp(b.x,50,W-50); b.y = clamp(b.y,50,H-50);

    b.trail.push({x:b.x,y:b.y});
    if (b.trail.length > 120) b.trail.shift();
  });
}

// ═══════════════════════════════════════════════════════
//  FOREGROUND LENS FLARES & AURORA
// ═══════════════════════════════════════════════════════
function paintForeground(t) {
  const ctx = layers[3].ctx;
  ctx.clearRect(0,0,W,H);

  // Aurora bands across the image (nebula edge illumination)
  for (let band = 0; band < 4; band++) {
    const bAngle = (band/4)*Math.PI + t*0.0001*(band%2?1:-1);
    const bLen   = Math.max(W,H)*1.2;
    const bX1    = cx + Math.cos(bAngle)*bLen;
    const bY1    = cy + Math.sin(bAngle)*bLen;
    const bX2    = cx - Math.cos(bAngle)*bLen;
    const bY2    = cy - Math.sin(bAngle)*bLen;

    // Perpendicular offset
    const pAngle = bAngle + Math.PI/2;
    const pOff   = (Math.sin(t*0.0005+band*1.5)*0.08+0.05*band) * Math.min(W,H);
    const ax = Math.cos(pAngle)*pOff, ay = Math.sin(pAngle)*pOff;

    const hue = [320,200,260,50][band];
    const aug = ctx.createLinearGradient(bX1+ax,bY1+ay,bX2+ax,bY2+ay);
    const alpha = 0.015 + 0.008*Math.sin(t*0.0008+band*2.1);
    aug.addColorStop(0, `hsla(${hue},70%,60%,0)`);
    aug.addColorStop(0.35, `hsla(${hue},70%,60%,${alpha})`);
    aug.addColorStop(0.5, `hsla(${hue+20},80%,70%,${alpha*1.5})`);
    aug.addColorStop(0.65, `hsla(${hue},70%,60%,${alpha})`);
    aug.addColorStop(1, `hsla(${hue},70%,60%,0)`);

    ctx.save();
    ctx.translate(ax,ay);
    ctx.strokeStyle = aug;
    ctx.lineWidth = 60 + band*30;
    ctx.beginPath(); ctx.moveTo(bX1,bY1); ctx.lineTo(bX2,bY2); ctx.stroke();
    ctx.restore();
  }

  // Massive body trails & glows
  BODIES.forEach(b => {
    // Trail
    if (b.trail.length > 2) {
      ctx.beginPath();
      b.trail.forEach((tp,ti) => {
        const a = (ti/b.trail.length);
        ti===0 ? ctx.moveTo(tp.x,tp.y) : ctx.lineTo(tp.x,tp.y);
      });
      const tg = ctx.createLinearGradient(b.trail[0].x,b.trail[0].y,b.x,b.y);
      tg.addColorStop(0, `hsla(${b.hue},80%,70%,0)`);
      tg.addColorStop(1, `hsla(${b.hue},80%,70%,0.3)`);
      ctx.strokeStyle = tg;
      ctx.lineWidth = b.r*0.6;
      ctx.lineCap = 'round'; ctx.stroke();
    }

    // Glow corona
    for (let ring = 3; ring >= 0; ring--) {
      const rScale = 1 + ring*1.8;
      const gr = ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r*rScale*3);
      gr.addColorStop(0,   `hsla(${b.hue},90%,95%,${0.6/Math.pow(ring+1,1.5)})`);
      gr.addColorStop(0.2, `hsla(${b.hue+20},80%,80%,${0.2/Math.pow(ring+1,1.5)})`);
      gr.addColorStop(1,   `hsla(${b.hue},70%,60%,0)`);
      ctx.fillStyle = gr;
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r*rScale*3,0,Math.PI*2); ctx.fill();
    }

    // Core
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    ctx.fillStyle = `hsl(${b.hue},30%,100%)`; ctx.fill();
  });

  // Lens flares from brightest bodies
  BODIES.slice(0,2).forEach((b,bi) => {
    const flareLen = Math.min(W,H)*0.4;
    const angles   = [0, Math.PI*0.25, Math.PI*0.5, Math.PI*0.75];
    angles.forEach(fa => {
      const f1x = b.x + Math.cos(fa)*flareLen;
      const f1y = b.y + Math.sin(fa)*flareLen;
      const f2x = b.x - Math.cos(fa)*flareLen;
      const f2y = b.y - Math.sin(fa)*flareLen;
      const flg = ctx.createLinearGradient(f1x,f1y,f2x,f2y);
      const fa2  = 0.04 + 0.02*Math.sin(t*0.003+bi);
      flg.addColorStop(0,   `hsla(${b.hue+30},60%,80%,0)`);
      flg.addColorStop(0.45,`hsla(${b.hue+30},60%,80%,${fa2})`);
      flg.addColorStop(0.5, `hsla(${b.hue},20%,100%,${fa2*1.5})`);
      flg.addColorStop(0.55,`hsla(${b.hue+30},60%,80%,${fa2})`);
      flg.addColorStop(1,   `hsla(${b.hue+30},60%,80%,0)`);
      ctx.strokeStyle = flg; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(f1x,f1y); ctx.lineTo(f2x,f2y); ctx.stroke();
    });
  });

  // Cursor nebula brush
  const cg = ctx.createRadialGradient(mouse.sx,mouse.sy,0,mouse.sx,mouse.sy,mouse.down?180:80);
  cg.addColorStop(0,   `rgba(200,180,255,${mouse.down?0.08:0.03})`);
  cg.addColorStop(1,   'rgba(0,0,0,0)');
  ctx.fillStyle = cg;
  ctx.beginPath(); ctx.arc(mouse.sx,mouse.sy,mouse.down?180:80,0,Math.PI*2); ctx.fill();
}

// ═══════════════════════════════════════════════════════
//  PARTICLES LAYER (c2)
// ═══════════════════════════════════════════════════════
function paintParticles(t) {
  const ctx = layers[2].ctx;
  ctx.clearRect(0,0,W,H);
  particles.forEach(p => { p.update(t); p.draw(ctx, t); });
}

// ═══════════════════════════════════════════════════════
//  UI UPDATE
// ═══════════════════════════════════════════════════════
let startTime = Date.now();
function updateUI(t) {
  const elapsed = Math.floor((Date.now()-startTime)/1000);
  const mm = String(Math.floor(elapsed/60)).padStart(2,'0');
  const ss = String(elapsed%60).padStart(2,'0');
  document.getElementById('elapsed').textContent = `${mm}:${ss}`;
  const totalV = BODIES.reduce((s,b) => s+Math.hypot(b.vx,b.vy), 0);
  document.getElementById('dv').textContent = (totalV/BODIES.length).toFixed(2);
  document.getElementById('starCount').textContent = STAR_COUNT + BODIES.length;
}

// ═══════════════════════════════════════════════════════
//  MAIN LOOP
// ═══════════════════════════════════════════════════════
let t = 0;
let nebulaFrame = 0;

function loop() {
  t++;

  // Smooth mouse
  mouse.sx = lerp(mouse.sx, mouse.x, 0.05);
  mouse.sy = lerp(mouse.sy, mouse.y, 0.05);

  // Nebula repaints every 3 frames (expensive)
  if (nebulaFrame % 3 === 0) paintNebula(t);
  nebulaFrame++;

  // Particles every frame
  paintParticles(t);

  // Bodies + foreground every frame
  updateBodies(t);
  paintForeground(t);

  updateUI(t);

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
