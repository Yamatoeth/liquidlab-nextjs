<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Burst — FORMA</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #04040c; overflow: hidden; width: 100vw; height: 100vh; cursor: crosshair; }
  canvas { display: block; }
  .label { position: fixed; bottom: 24px; left: 24px; font-family: 'Courier New', monospace; font-size: 11px; letter-spacing: 0.15em; color: rgba(255,255,255,0.25); text-transform: uppercase; pointer-events: none; }
  .hint { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Courier New', monospace; font-size: 13px; letter-spacing: 0.2em; color: rgba(255,255,255,0.2); text-transform: uppercase; pointer-events: none; transition: opacity 0.5s; text-align: center; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint" id="hint">Click anywhere</div>
<div class="label">Burst · Click to explode</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

const hint = document.getElementById('hint');
let hintHidden = false;

const PALETTES = [
  ['#ff6eb4','#ff9de2','#ffcff4','#ff3d9a'],
  ['#6eb4ff','#9de2ff','#cff4ff','#3d9aff'],
  ['#6effb4','#9dffe2','#cffff4','#3dff9a'],
  ['#ffb46e','#ffd89d','#fff4cf','#ff9a3d'],
  ['#b46eff','#d89dff','#f4cfff','#9a3dff'],
  ['#ffff6e','#ffff9d','#ffffcf','#ffff3d'],
];

let paletteIdx = 0;
let particles = [];
let time = 0;

class Burst {
  constructor(x, y, palette) {
    this.x = x; this.y = y;
    this.palette = palette;
    this.dead = false;
    this.particles = [];
    const N = 80 + Math.floor(Math.random() * 60);
    for (let i = 0; i < N; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 2 + Math.random() * 8;
      const color = palette[Math.floor(Math.random() * palette.length)];
      const type = Math.random() > 0.4 ? 'dot' : 'line';
      this.particles.push({
        x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
        life: 1, decay: 0.012 + Math.random() * 0.018,
        size: type === 'dot' ? 2 + Math.random() * 4 : 1,
        length: type === 'line' ? 8 + Math.random() * 16 : 0,
        color, type,
        gravity: 0.1 + Math.random() * 0.15,
        drag: 0.97 + Math.random() * 0.02,
      });
    }
    // Central flash
    this.flash = 1;
  }
  update() {
    this.flash *= 0.85;
    this.particles.forEach(p => {
      p.vy += p.gravity;
      p.vx *= p.drag; p.vy *= p.drag;
      p.x += p.vx; p.y += p.vy;
      p.life -= p.decay;
    });
    this.particles = this.particles.filter(p => p.life > 0);
    if (this.particles.length === 0) this.dead = true;
  }
  draw(ctx) {
    if (this.flash > 0.01) {
      const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 60 * this.flash);
      grad.addColorStop(0, `rgba(255,255,255,${this.flash * 0.8})`);
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(this.x, this.y, 60, 0, Math.PI*2); ctx.fill();
    }
    this.particles.forEach(p => {
      ctx.save();
      ctx.globalAlpha = Math.max(0, p.life);
      if (p.type === 'dot') {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2);
        ctx.fillStyle = p.color;
        ctx.fill();
        // glow
        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
        g.addColorStop(0, p.color + '80');
        g.addColorStop(1, p.color + '00');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 4, 0, Math.PI*2); ctx.fill();
      } else {
        const angle = Math.atan2(p.vy, p.vx);
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 2 * p.life;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x - Math.cos(angle) * p.length * p.life, p.y - Math.sin(angle) * p.length * p.life);
        ctx.stroke();
      }
      ctx.restore();
    });
  }
}

let bursts = [];

function explode(x, y) {
  const palette = PALETTES[paletteIdx % PALETTES.length];
  paletteIdx++;
  bursts.push(new Burst(x, y, palette));
  if (!hintHidden) { hint.style.opacity = '0'; hintHidden = true; }
}

canvas.addEventListener('click', e => explode(e.clientX, e.clientY));
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  Array.from(e.touches).forEach(t => explode(t.clientX, t.clientY));
}, { passive: false });

// Auto burst at start
setTimeout(() => explode(W/2, H/2), 600);
setTimeout(() => explode(W*0.3, H*0.4), 1200);
setTimeout(() => explode(W*0.7, H*0.6), 1700);

function draw() {
  ctx.fillStyle = 'rgba(4,4,12,0.25)';
  ctx.fillRect(0, 0, W, H);
  bursts.forEach(b => { b.update(); b.draw(ctx); });
  bursts = bursts.filter(b => !b.dead);
  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
