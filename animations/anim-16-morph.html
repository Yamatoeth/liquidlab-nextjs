<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Morph — FORMA</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Syne:wght@700;800&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #05050c; overflow: hidden; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; }
  .stage { position: relative; width: min(500px, 90vw); height: min(500px, 90vw); }
  svg { width: 100%; height: 100%; overflow: visible; }
  .label { position: fixed; bottom: 24px; left: 24px; font-family: 'Courier New', monospace; font-size: 11px; letter-spacing: 0.15em; color: rgba(255,255,255,0.2); text-transform: uppercase; }
  .center-text {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Syne', sans-serif; font-weight: 800;
    font-size: clamp(28px, 5vw, 48px);
    letter-spacing: 0.15em;
    color: rgba(255,255,255,0.85);
    text-transform: uppercase;
    pointer-events: none;
    text-align: center;
    mix-blend-mode: overlay;
  }
  canvas { position: fixed; inset: 0; z-index: 0; pointer-events: none; }
  .stage { z-index: 1; }
</style>
</head>
<body>
<canvas id="bg"></canvas>
<div class="stage">
  <svg viewBox="-250 -250 500 500" id="svg">
    <defs>
      <filter id="blur1"><feGaussianBlur stdDeviation="8"/></filter>
      <filter id="blur2"><feGaussianBlur stdDeviation="4"/></filter>
    </defs>
    <!-- Glow layer -->
    <path id="blob-glow" filter="url(#blur1)" opacity="0.5"/>
    <!-- Main blob -->
    <path id="blob-main"/>
    <!-- Inner highlight -->
    <path id="blob-inner" filter="url(#blur2)" opacity="0.3"/>
  </svg>
  <div class="center-text" id="centerText">Morph</div>
</div>
<div class="label">Morph · Organic shape animation</div>
<script>
// BG
const canvas = document.getElementById('bg');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth; canvas.height = window.innerHeight;
ctx.fillStyle = '#05050c'; ctx.fillRect(0,0,canvas.width,canvas.height);

const PALETTES = [
  { from: '#7c6af7', to: '#f76af0', text: 'Design' },
  { from: '#6af7c8', to: '#6ab4f7', text: 'Build' },
  { from: '#f7a46a', to: '#f76a6a', text: 'Launch' },
  { from: '#6af7f7', to: '#7c6af7', text: 'Scale' },
  { from: '#f76af0', to: '#f7f76a', text: 'Create' },
];

let paletteIdx = 0;
let paletteLerp = 0;
const words = ['Design','Build','Launch','Scale','Create'];
let wordIdx = 0;

function hexToRgb(h) {
  const r = parseInt(h.slice(1,3),16), g = parseInt(h.slice(3,5),16), b = parseInt(h.slice(5,7),16);
  return [r,g,b];
}
function lerpColor(c1,c2,t) {
  const a=hexToRgb(c1), b=hexToRgb(c2);
  return `rgb(${Math.round(a[0]+(b[0]-a[0])*t)},${Math.round(a[1]+(b[1]-a[1])*t)},${Math.round(a[2]+(b[2]-a[2])*t)})`;
}

// Generate blob path using sine wave perturbations
function blobPath(points, time, amp, freq, phase=0) {
  const pts = [];
  for (let i=0; i<points; i++) {
    const angle = (i/points)*Math.PI*2;
    let r = 180;
    for (let h=1; h<=freq; h++) {
      r += Math.sin(angle*h*2 + time*0.3 + phase + h) * (amp/h);
      r += Math.cos(angle*h*3 + time*0.2 + phase*1.3 + h*0.7) * (amp*0.5/h);
    }
    pts.push({ x: Math.cos(angle)*r, y: Math.sin(angle)*r });
  }
  // Catmull-Rom to bezier approximation
  let d = `M ${pts[0].x.toFixed(1)} ${pts[0].y.toFixed(1)}`;
  for (let i=0; i<pts.length; i++) {
    const p0 = pts[(i-1+pts.length)%pts.length];
    const p1 = pts[i];
    const p2 = pts[(i+1)%pts.length];
    const p3 = pts[(i+2)%pts.length];
    const cp1x = p1.x + (p2.x-p0.x)/6;
    const cp1y = p1.y + (p2.y-p0.y)/6;
    const cp2x = p2.x - (p3.x-p1.x)/6;
    const cp2y = p2.y - (p3.y-p1.y)/6;
    d += ` C ${cp1x.toFixed(1)} ${cp1y.toFixed(1)}, ${cp2x.toFixed(1)} ${cp2y.toFixed(1)}, ${p2.x.toFixed(1)} ${p2.y.toFixed(1)}`;
  }
  return d + ' Z';
}

const blobMain = document.getElementById('blob-main');
const blobGlow = document.getElementById('blob-glow');
const blobInner = document.getElementById('blob-inner');
const centerText = document.getElementById('centerText');
const svg = document.getElementById('svg');
let time = 0;

// Word cycle
setInterval(() => {
  wordIdx = (wordIdx+1)%words.length;
  paletteIdx = wordIdx;
  centerText.style.transition = 'opacity 0.3s';
  centerText.style.opacity = '0';
  setTimeout(() => {
    centerText.textContent = words[wordIdx];
    centerText.style.opacity = '1';
  }, 300);
}, 2500);

function animate() {
  time += 0.008;
  const d = blobPath(80, time, 40, 4);
  const d2 = blobPath(60, time*1.3, 20, 3, 1.5);

  const pal = PALETTES[paletteIdx];
  const nextPal = PALETTES[(paletteIdx+1)%PALETTES.length];

  blobMain.setAttribute('d', d);
  blobGlow.setAttribute('d', d);
  blobInner.setAttribute('d', d2);

  // Animated gradient via inline style
  const c1 = pal.from;
  const c2 = pal.to;

  // Create/update SVG gradient
  let grad = svg.querySelector('#blobGrad');
  if (!grad) {
    const defs = svg.querySelector('defs');
    grad = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
    grad.id = 'blobGrad';
    grad.setAttribute('x1','0%'); grad.setAttribute('y1','0%');
    grad.setAttribute('x2','100%'); grad.setAttribute('y2','100%');
    const s1 = document.createElementNS('http://www.w3.org/2000/svg','stop');
    s1.setAttribute('offset','0%'); s1.id='gs1';
    const s2 = document.createElementNS('http://www.w3.org/2000/svg','stop');
    s2.setAttribute('offset','100%'); s2.id='gs2';
    grad.appendChild(s1); grad.appendChild(s2);
    defs.appendChild(grad);
  }
  const angle = time * 0.5;
  grad.setAttribute('x1', (50+Math.cos(angle)*50)+'%');
  grad.setAttribute('y1', (50+Math.sin(angle)*50)+'%');
  grad.setAttribute('x2', (50-Math.cos(angle)*50)+'%');
  grad.setAttribute('y2', (50-Math.sin(angle)*50)+'%');
  svg.querySelector('#gs1').setAttribute('stop-color', c1);
  svg.querySelector('#gs2').setAttribute('stop-color', c2);

  blobMain.setAttribute('fill', 'url(#blobGrad)');
  blobGlow.setAttribute('fill', c1);
  blobInner.setAttribute('fill', '#fff');

  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
