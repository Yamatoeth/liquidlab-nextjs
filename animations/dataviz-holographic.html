<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PRISM — Data Visualization</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syne:wght@400;700;800&display=swap');

  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --violet: #8b2fc9;
    --pink: #ff2d8d;
    --lilac: #c084fc;
    --rose: #fb7185;
    --white: #fff0ff;
    --dark: #06010f;
    --mid: #0e0520;
    --glow-v: rgba(139, 47, 201, 0.5);
    --glow-p: rgba(255, 45, 141, 0.5);
  }

  html, body {
    width: 100%; height: 100%;
    background: var(--dark);
    overflow: hidden;
    cursor: none;
    font-family: 'Syne', sans-serif;
  }

  canvas { display: block; }

  /* Cursor */
  #cursor {
    position: fixed;
    width: 8px; height: 8px;
    background: var(--pink);
    border-radius: 50%;
    pointer-events: none;
    z-index: 9999;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 12px var(--pink), 0 0 30px var(--glow-p);
    mix-blend-mode: screen;
    transition: width .2s, height .2s;
  }
  #cursor-aura {
    position: fixed;
    width: 50px; height: 50px;
    border-radius: 50%;
    border: 1px solid rgba(255, 45, 141, 0.3);
    pointer-events: none;
    z-index: 9998;
    transform: translate(-50%, -50%);
    transition: all 0.25s ease;
    background: radial-gradient(circle, rgba(255,45,141,0.04) 0%, transparent 70%);
  }

  /* Noise grain overlay */
  #grain {
    position: fixed; inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 6;
    opacity: 0.6;
  }

  /* Vignette */
  #vignette {
    position: fixed; inset: 0;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(6,1,15,0.85) 100%);
    pointer-events: none;
    z-index: 5;
  }

  /* UI */
  #ui {
    position: fixed; inset: 0;
    z-index: 10;
    pointer-events: none;
    padding: 36px 48px;
    display: grid;
    grid-template-rows: auto 1fr auto;
  }

  /* Header */
  .header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
  }

  .brand {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .logo {
    font-family: 'Syne', sans-serif;
    font-weight: 800;
    font-size: 32px;
    letter-spacing: 10px;
    background: linear-gradient(135deg, var(--lilac), var(--pink), var(--rose));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    filter: drop-shadow(0 0 20px rgba(192, 132, 252, 0.4));
    animation: holoBrand 4s ease-in-out infinite alternate;
  }

  @keyframes holoBrand {
    from { filter: drop-shadow(0 0 15px rgba(192,132,252,0.3)); }
    to   { filter: drop-shadow(0 0 35px rgba(255,45,141,0.5)); }
  }

  .logo-sub {
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    letter-spacing: 4px;
    color: rgba(192, 132, 252, 0.5);
    text-transform: uppercase;
  }

  .live-panel {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 8px;
  }

  .live-badge {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 14px;
    border: 1px solid rgba(255,45,141,0.3);
    background: rgba(255,45,141,0.05);
    backdrop-filter: blur(10px);
  }

  .live-dot {
    width: 7px; height: 7px;
    background: var(--pink);
    border-radius: 50%;
    animation: livePulse 1s ease-in-out infinite;
    box-shadow: 0 0 8px var(--pink);
  }

  @keyframes livePulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.3); opacity: 0.6; }
  }

  .live-text {
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    letter-spacing: 3px;
    color: var(--pink);
    text-transform: uppercase;
  }

  .clock {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    letter-spacing: 2px;
    color: rgba(192,132,252,0.4);
  }

  /* Metric cards — right side */
  .metrics {
    position: absolute;
    top: 50%;
    right: 48px;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 14px;
    pointer-events: all;
  }

  .metric-card {
    width: 180px;
    padding: 16px 20px;
    border: 1px solid rgba(139,47,201,0.25);
    background: rgba(14,5,32,0.7);
    backdrop-filter: blur(16px);
    position: relative;
    overflow: hidden;
    opacity: 0;
    transform: translateX(20px);
    animation: slideIn 0.6s ease forwards;
    cursor: none;
    transition: border-color 0.3s;
  }

  .metric-card:hover {
    border-color: rgba(255,45,141,0.5);
  }

  .metric-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 3px; height: 100%;
    background: linear-gradient(to bottom, var(--violet), var(--pink));
  }

  .metric-card::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(139,47,201,0.06) 0%, transparent 60%);
  }

  .metric-card:nth-child(1) { animation-delay: 0.4s; }
  .metric-card:nth-child(2) { animation-delay: 0.6s; }
  .metric-card:nth-child(3) { animation-delay: 0.8s; }
  .metric-card:nth-child(4) { animation-delay: 1.0s; }

  @keyframes slideIn {
    to { opacity: 1; transform: translateX(0); }
  }

  .metric-label {
    font-family: 'Space Mono', monospace;
    font-size: 9px;
    letter-spacing: 3px;
    color: rgba(192,132,252,0.5);
    text-transform: uppercase;
    margin-bottom: 8px;
  }

  .metric-value {
    font-family: 'Syne', sans-serif;
    font-weight: 800;
    font-size: 26px;
    color: var(--white);
    line-height: 1;
    letter-spacing: -1px;
  }

  .metric-value .unit {
    font-size: 13px;
    color: var(--lilac);
    font-weight: 400;
    letter-spacing: 1px;
  }

  .metric-bar {
    margin-top: 10px;
    height: 2px;
    background: rgba(139,47,201,0.15);
    position: relative;
    overflow: hidden;
  }

  .metric-fill {
    height: 100%;
    background: linear-gradient(to right, var(--violet), var(--pink));
    box-shadow: 0 0 8px var(--pink);
    animation: fillBar 2s ease forwards;
    animation-delay: inherit;
    width: 0%;
  }

  @keyframes fillBar {
    to { width: var(--fill); }
  }

  /* Center headline */
  .center {
    position: absolute;
    left: 48px;
    top: 50%;
    transform: translateY(-50%);
    max-width: 400px;
  }

  .eyebrow {
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    letter-spacing: 5px;
    color: rgba(255,45,141,0.6);
    text-transform: uppercase;
    margin-bottom: 18px;
    opacity: 0;
    animation: fadeUp 0.7s ease 0.5s forwards;
  }

  .headline {
    font-weight: 800;
    font-size: clamp(30px, 3.5vw, 52px);
    line-height: 1.08;
    color: var(--white);
    margin-bottom: 20px;
    opacity: 0;
    animation: fadeUp 0.7s ease 0.7s forwards;
  }

  .headline em {
    font-style: normal;
    background: linear-gradient(135deg, var(--lilac) 0%, var(--pink) 50%, var(--rose) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .desc {
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    line-height: 1.8;
    color: rgba(240,220,255,0.4);
    letter-spacing: 0.3px;
    opacity: 0;
    animation: fadeUp 0.7s ease 0.9s forwards;
  }

  /* Bottom */
  .bottom {
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
  }

  .wave-controls {
    display: flex;
    gap: 12px;
    pointer-events: all;
    opacity: 0;
    animation: fadeUp 0.7s ease 1.2s forwards;
  }

  .ctrl-btn {
    padding: 10px 22px;
    font-family: 'Space Mono', monospace;
    font-size: 9px;
    letter-spacing: 3px;
    text-transform: uppercase;
    cursor: none;
    border: 1px solid rgba(139,47,201,0.4);
    background: rgba(139,47,201,0.08);
    color: var(--lilac);
    transition: all 0.3s;
    backdrop-filter: blur(8px);
  }

  .ctrl-btn:hover, .ctrl-btn.active {
    background: rgba(255,45,141,0.15);
    border-color: rgba(255,45,141,0.6);
    color: var(--pink);
    box-shadow: 0 0 20px rgba(255,45,141,0.15);
  }

  .bottom-right {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 6px;
  }

  .coord-display {
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    color: rgba(192,132,252,0.3);
  }

  .hint-bottom {
    font-family: 'Space Mono', monospace;
    font-size: 9px;
    letter-spacing: 3px;
    color: rgba(255,45,141,0.3);
    text-transform: uppercase;
    animation: fadeHint 3s ease-in-out infinite;
  }

  @keyframes fadeHint { 0%,100%{opacity:.3} 50%{opacity:.8} }
  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(16px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  /* Holographic lines */
  .holo-line {
    position: fixed;
    left: 0; right: 0;
    height: 1px;
    pointer-events: none;
    z-index: 4;
    opacity: 0.12;
  }
  .holo-line-1 { top: 33%; background: linear-gradient(to right, transparent, var(--violet), transparent); }
  .holo-line-2 { top: 66%; background: linear-gradient(to right, transparent, var(--pink), transparent); }
</style>
</head>
<body>

<div id="cursor"></div>
<div id="cursor-aura"></div>
<div id="grain"></div>
<div id="vignette"></div>
<div class="holo-line holo-line-1"></div>
<div class="holo-line holo-line-2"></div>

<div id="ui">
  <div class="header">
    <div class="brand">
      <div class="logo">PRISM</div>
      <div class="logo-sub">// Holographic Data Engine</div>
    </div>
    <div class="live-panel">
      <div class="live-badge">
        <div class="live-dot"></div>
        <div class="live-text">Live Feed</div>
      </div>
      <div class="clock" id="clock">--:--:--</div>
    </div>
  </div>

  <div class="center">
    <div class="eyebrow">// flux de données — stream actif</div>
    <h1 class="headline">Visualisez<br>vos données<br>en <em>temps réel</em></h1>
    <p class="desc">Chaque sommet représente<br>un point de donnée vivant.<br>La surface respire avec le marché.</p>
  </div>

  <div class="metrics">
    <div class="metric-card">
      <div class="metric-label">Volume 24h</div>
      <div class="metric-value" id="m1">—</div>
      <div class="metric-bar"><div class="metric-fill" style="--fill:78%"></div></div>
    </div>
    <div class="metric-card">
      <div class="metric-label">Transactions</div>
      <div class="metric-value" id="m2">—</div>
      <div class="metric-bar"><div class="metric-fill" style="--fill:62%"></div></div>
    </div>
    <div class="metric-card">
      <div class="metric-label">Liquidité</div>
      <div class="metric-value" id="m3">—</div>
      <div class="metric-bar"><div class="metric-fill" style="--fill:91%"></div></div>
    </div>
    <div class="metric-card">
      <div class="metric-label">Croissance</div>
      <div class="metric-value" id="m4">—</div>
      <div class="metric-bar"><div class="metric-fill" style="--fill:45%"></div></div>
    </div>
  </div>

  <div class="bottom">
    <div class="wave-controls">
      <button class="ctrl-btn active" id="btn-wave" onclick="setMode('wave')">Vague</button>
      <button class="ctrl-btn" id="btn-pulse" onclick="setMode('pulse')">Pulse</button>
      <button class="ctrl-btn" id="btn-chaos" onclick="setMode('chaos')">Chaos</button>
    </div>
    <div class="bottom-right">
      <div class="coord-display" id="coords">X: 0.000 — Y: 0.000</div>
      <div class="hint-bottom">↕ scroll · ⟵ glisser ⟶</div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ====== SETUP ======
const W = window.innerWidth, H = window.innerHeight;
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(W, H);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.appendChild(renderer.domElement);
Object.assign(renderer.domElement.style, {
  position:'fixed', inset:'0', zIndex:'0'
});

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x06010f);
scene.fog = new THREE.FogExp2(0x06010f, 0.028);

const camera = new THREE.PerspectiveCamera(55, W/H, 0.1, 300);
camera.position.set(0, 14, 22);
camera.lookAt(0, 0, 0);

// ====== MOUSE ======
const mouse = { x: 0, y: 0 };
const cursor = document.getElementById('cursor');
const aura   = document.getElementById('cursor-aura');

document.addEventListener('mousemove', e => {
  mouse.x = (e.clientX / W) * 2 - 1;
  mouse.y = -(e.clientY / H) * 2 + 1;
  cursor.style.cssText += `left:${e.clientX}px;top:${e.clientY}px;`;
  aura.style.cssText   += `left:${e.clientX}px;top:${e.clientY}px;`;
  document.getElementById('coords').textContent =
    `X: ${mouse.x.toFixed(3)} — Y: ${mouse.y.toFixed(3)}`;
});

// ====== GRID WAVE ======
const COLS = 80, ROWS = 80;
const SIZE = 28;
const geo = new THREE.PlaneGeometry(SIZE, SIZE, COLS - 1, ROWS - 1);
geo.rotateX(-Math.PI / 2);

const posArr = geo.attributes.position.array;
const baseY  = new Float32Array(posArr.length / 3);
for (let i = 0; i < posArr.length / 3; i++) baseY[i] = 0;

// Build vertex colors
const colors = new Float32Array((posArr.length / 3) * 3);
geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const mat = new THREE.MeshStandardMaterial({
  vertexColors: true,
  metalness: 0.2,
  roughness: 0.6,
  side: THREE.DoubleSide,
  transparent: true,
  opacity: 0.92,
});
const wave = new THREE.Mesh(geo, mat);
scene.add(wave);

// Wireframe overlay
const wireMat = new THREE.MeshBasicMaterial({
  color: 0x8b2fc9, wireframe: true, transparent: true, opacity: 0.07
});
const wireOverlay = new THREE.Mesh(geo.clone(), wireMat);
wireOverlay.position.y = 0.01;
scene.add(wireOverlay);

// ====== EDGE GLOW LINES ======
function addEdgeLine(x1,z1,x2,z2, color) {
  const pts = [new THREE.Vector3(x1,0,z1), new THREE.Vector3(x2,0,z2)];
  const lg = new THREE.BufferGeometry().setFromPoints(pts);
  const lm = new THREE.LineBasicMaterial({ color, transparent:true, opacity:0.4 });
  scene.add(new THREE.Line(lg, lm));
}
const half = SIZE / 2;
addEdgeLine(-half,  -half,  half,  -half, 0xff2d8d);
addEdgeLine(-half,   half,  half,   half, 0x8b2fc9);
addEdgeLine(-half,  -half, -half,   half, 0xc084fc);
addEdgeLine( half,  -half,  half,   half, 0xfb7185);

// ====== FLOATING SPHERES (data nodes) ======
const nodes = [];
const nodeColors = [0x8b2fc9, 0xff2d8d, 0xc084fc, 0xfb7185, 0xe879f9];
for (let i = 0; i < 30; i++) {
  const r = 0.06 + Math.random() * 0.18;
  const g = new THREE.SphereGeometry(r, 12, 12);
  const c = nodeColors[Math.floor(Math.random() * nodeColors.length)];
  const m = new THREE.MeshStandardMaterial({
    color: c, emissive: c, emissiveIntensity: 0.8,
    metalness: 1, roughness: 0,
  });
  const mesh = new THREE.Mesh(g, m);
  const px = (Math.random() - 0.5) * SIZE;
  const pz = (Math.random() - 0.5) * SIZE;
  mesh.position.set(px, 0.5 + Math.random() * 3, pz);
  mesh.userData = {
    ox: px, oz: pz,
    speed: 0.4 + Math.random() * 0.8,
    offset: Math.random() * Math.PI * 2,
    amp: 0.5 + Math.random() * 1.5,
  };
  scene.add(mesh);
  nodes.push(mesh);
}

// ====== PARTICLES RAIN ======
const pCount = 1200;
const pPos   = new Float32Array(pCount * 3);
const pVel   = new Float32Array(pCount);
for (let i = 0; i < pCount; i++) {
  pPos[i*3]   = (Math.random() - 0.5) * 40;
  pPos[i*3+1] = Math.random() * 20 - 2;
  pPos[i*3+2] = (Math.random() - 0.5) * 40;
  pVel[i]     = 0.02 + Math.random() * 0.06;
}
const pGeo = new THREE.BufferGeometry();
pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
const pMat = new THREE.PointsMaterial({
  size: 0.04, color: 0xc084fc, transparent: true,
  opacity: 0.5, blending: THREE.AdditiveBlending, depthWrite: false,
});
const ptCloud = new THREE.Points(pGeo, pMat);
scene.add(ptCloud);

// ====== LIGHTS ======
scene.add(new THREE.AmbientLight(0x1a0033, 3));

const lV = new THREE.PointLight(0x8b2fc9, 6, 30);
lV.position.set(-8, 8, -5);
scene.add(lV);

const lP = new THREE.PointLight(0xff2d8d, 5, 25);
lP.position.set(8, 6, 5);
scene.add(lP);

const lR = new THREE.PointLight(0xfb7185, 2, 20);
lR.position.set(0, 15, 0);
scene.add(lR);

const lUnder = new THREE.PointLight(0xe879f9, 3, 15);
lUnder.position.set(0, -3, 0);
scene.add(lUnder);

// ====== MODE ======
let mode = 'wave';
window.setMode = function(m) {
  mode = m;
  document.querySelectorAll('.ctrl-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('btn-' + m).classList.add('active');
};

// ====== COLOR HELPERS ======
const colorA = new THREE.Color(0x8b2fc9);
const colorB = new THREE.Color(0xff2d8d);
const colorC = new THREE.Color(0xfb7185);
const colorD = new THREE.Color(0x06010f);

function heightToColor(h, maxH) {
  const t = Math.max(0, Math.min(1, (h + maxH) / (2 * maxH)));
  const col = new THREE.Color();
  if (t < 0.33) col.lerpColors(colorD, colorA, t / 0.33);
  else if (t < 0.66) col.lerpColors(colorA, colorB, (t - 0.33) / 0.33);
  else col.lerpColors(colorB, colorC, (t - 0.66) / 0.34);
  return col;
}

// ====== METRICS ANIMATION ======
const metrics = [
  { id: 'm1', val: 2847391, fmt: v => '$' + (v/1000000).toFixed(2) + '<span class="unit">M</span>' },
  { id: 'm2', val: 14823,   fmt: v => Math.floor(v).toLocaleString() },
  { id: 'm3', val: 91.4,    fmt: v => v.toFixed(1) + '<span class="unit">%</span>' },
  { id: 'm4', val: 28.7,    fmt: v => '+' + v.toFixed(1) + '<span class="unit">%</span>' },
];
metrics.forEach((m, i) => {
  let cur = 0;
  const el = document.getElementById(m.id);
  setTimeout(() => {
    const step = () => {
      cur += m.val / 60;
      if (cur >= m.val) cur = m.val;
      el.innerHTML = m.fmt(cur);
      if (cur < m.val) requestAnimationFrame(step);
    };
    step();
  }, 800 + i * 200);
});

// Fluctuate metrics
setInterval(() => {
  const delta = (Math.random() - 0.48) * 0.8;
  metrics[2].val = Math.max(70, Math.min(99, metrics[2].val + delta));
  metrics[3].val = Math.max(10, Math.min(80, metrics[3].val + (Math.random()-0.45)*0.3));
  document.getElementById('m3').innerHTML = metrics[2].fmt(metrics[2].val);
  document.getElementById('m4').innerHTML = metrics[3].fmt(metrics[3].val);
}, 1800);

// Clock
setInterval(() => {
  document.getElementById('clock').textContent =
    new Date().toLocaleTimeString('fr-FR', { hour12: false });
}, 1000);

// ====== SCROLL ======
let zoom = 22;
window.addEventListener('wheel', e => {
  zoom += e.deltaY * 0.015;
  zoom = Math.max(10, Math.min(40, zoom));
});

// ====== ANIMATE ======
let t = 0;
function animate() {
  requestAnimationFrame(animate);
  t += 0.012;

  // Camera
  const tx = mouse.x * 4;
  const ty = 14 + mouse.y * 3;
  camera.position.x += (tx - camera.position.x) * 0.03;
  camera.position.y += (ty - camera.position.y) * 0.03;
  camera.position.z += (zoom - camera.position.z) * 0.05;
  camera.lookAt(0, 0, 0);

  // Wave deformation
  const pos = geo.attributes.position;
  const col = geo.attributes.color;
  const segs = COLS - 1;

  for (let i = 0; i < pos.count; i++) {
    const col_i = i % COLS;
    const row_i = Math.floor(i / COLS);
    const nx = col_i / (COLS - 1) - 0.5;
    const nz = row_i / (ROWS - 1) - 0.5;

    let h = 0;
    const dist = Math.sqrt(nx*nx + nz*nz);
    const mx = mouse.x * 0.5;
    const my = mouse.y * 0.5;

    if (mode === 'wave') {
      h = Math.sin(nx * 10 + t * 2.5) * 0.8
        + Math.sin(nz * 8 + t * 1.8) * 0.6
        + Math.sin((nx + nz) * 6 + t * 3) * 0.4
        + Math.sin(dist * 15 - t * 4 + mx * 5) * (0.5 + my * 0.5);

    } else if (mode === 'pulse') {
      const r = Math.sqrt((nx - mx*0.3)**2 + (nz - my*0.3)**2);
      h = Math.sin(r * 25 - t * 6) * Math.exp(-r * 4) * 3.5
        + Math.sin(nx * 5 + t * 1.5) * 0.4
        + Math.sin(nz * 5 + t * 1.5) * 0.4;

    } else { // chaos
      h = Math.sin(nx * 12 + t * 3 + Math.sin(nz * 8 + t)) * 0.9
        + Math.cos(nz * 10 - t * 2.5 + Math.cos(nx * 6 + t * 1.5)) * 0.7
        + Math.sin(dist * 20 - t * 5) * 0.5
        + (Math.random() - 0.5) * 0.04;
    }

    // Mouse influence
    const mdx = nx - mx * 0.3;
    const mdz = nz - my * 0.3;
    const mdist = Math.sqrt(mdx*mdx + mdz*mdz);
    h += Math.exp(-mdist * 8) * 1.2;

    pos.setY(i, h);

    // Vertex color
    const c = heightToColor(h, 2.5);
    col.setXYZ(i, c.r, c.g, c.b);
  }

  pos.needsUpdate = true;
  col.needsUpdate = true;
  geo.computeVertexNormals();

  // Sync wire overlay
  wireOverlay.geometry.attributes.position.array.set(pos.array);
  wireOverlay.geometry.attributes.position.needsUpdate = true;

  // Nodes float on wave surface
  nodes.forEach(n => {
    const { ox, oz, speed, offset, amp } = n.userData;
    const t2 = t * speed + offset;
    n.position.x = ox + Math.sin(t2 * 0.4) * 0.5;
    n.position.z = oz + Math.cos(t2 * 0.3) * 0.5;

    // Sample wave height under node
    const nx2 = n.position.x / SIZE + 0.5;
    const nz2 = n.position.z / SIZE + 0.5;
    const hi  = Math.sin(nx2 * 10 + t * 2.5) * 0.8 + Math.sin(nz2 * 8 + t * 1.8) * 0.6;
    n.position.y = hi + 0.5 + Math.sin(t2) * 0.2;
    n.material.emissiveIntensity = 0.6 + Math.sin(t2 * 2) * 0.4;
  });

  // Particle rain
  const pp = pGeo.attributes.position.array;
  for (let i = 0; i < pCount; i++) {
    pp[i*3+1] -= pVel[i];
    if (pp[i*3+1] < -3) {
      pp[i*3+1] = 18;
      pp[i*3]   = (Math.random()-0.5)*40;
      pp[i*3+2] = (Math.random()-0.5)*40;
    }
  }
  pGeo.attributes.position.needsUpdate = true;

  // Lights orbit
  lV.position.x = Math.sin(t * 0.5) * 10;
  lV.position.z = Math.cos(t * 0.5) * 10;
  lP.position.x = Math.cos(t * 0.4 + 1) * 10;
  lP.position.z = Math.sin(t * 0.4 + 1) * 10;
  lV.intensity  = 5 + Math.sin(t * 2.1) * 1.5;
  lP.intensity  = 4 + Math.cos(t * 1.7) * 1;

  renderer.render(scene, camera);
}

animate();

// ====== RESIZE ======
window.addEventListener('resize', () => {
  const w = innerWidth, h = innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});
</script>
</body>
</html>
