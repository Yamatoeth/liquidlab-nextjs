<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MATRIX MAZE — Infinite Labyrinth</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Oswald:wght@200;400;700&display=swap');

  *, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }

  :root {
    --neon:   #00ff41;
    --mid:    #00cc33;
    --dim:    #007a1f;
    --dark:   #001a09;
    --abyss:  #000d04;
    --glow:   rgba(0,255,65,0.4);
    --border: rgba(0,255,65,0.15);
    --white:  #e0ffe8;
  }

  html, body {
    width:100%; height:100%;
    background: var(--abyss);
    overflow:hidden; cursor:none;
    font-family: 'Share Tech Mono', monospace;
  }

  canvas { display:block; position:fixed; inset:0; z-index:0; }

  /* Cursor */
  #cur {
    position:fixed; pointer-events:none; z-index:9999;
    width:4px; height:4px; border-radius:50%;
    background: var(--neon);
    transform:translate(-50%,-50%);
    box-shadow: 0 0 8px var(--neon), 0 0 20px var(--glow);
    mix-blend-mode: screen;
  }
  #cur-cross {
    position:fixed; pointer-events:none; z-index:9998;
    width:20px; height:20px;
    transform:translate(-50%,-50%);
  }
  #cur-cross::before, #cur-cross::after {
    content:''; position:absolute; background: rgba(0,255,65,0.6);
  }
  #cur-cross::before { width:1px; height:100%; left:50%; top:0; }
  #cur-cross::after  { width:100%; height:1px; top:50%; left:0; }

  /* Rain overlay canvas */
  #rain-canvas {
    position:fixed; inset:0; z-index:3; pointer-events:none;
    opacity:0.18;
  }

  /* Scanlines */
  #scan {
    position:fixed; inset:0; pointer-events:none; z-index:5;
    background: repeating-linear-gradient(
      0deg, transparent, transparent 2px,
      rgba(0,255,65,0.025) 2px, rgba(0,255,65,0.025) 4px
    );
  }

  /* Vignette */
  #vig {
    position:fixed; inset:0; pointer-events:none; z-index:4;
    background: radial-gradient(ellipse at 50% 50%, transparent 30%, rgba(0,13,4,0.9) 100%);
  }

  /* Glitch line */
  #glitch {
    position:fixed; pointer-events:none; z-index:6;
    left:0; right:0; height:2px;
    background: var(--neon);
    opacity:0;
    box-shadow: 0 0 12px var(--neon);
    animation: glitchLine 6s ease-in-out infinite;
  }
  @keyframes glitchLine {
    0%,100%{opacity:0;top:0%}
    48%{opacity:0;top:40%}
    50%{opacity:0.7;top:42%}
    52%{opacity:0;top:44%}
    78%{opacity:0;top:70%}
    80%{opacity:0.4;top:72%}
    82%{opacity:0;top:74%}
  }

  /* UI */
  #ui {
    position:fixed; inset:0; z-index:10; pointer-events:none;
    padding:36px 46px;
    display:flex; flex-direction:column; justify-content:space-between;
  }

  /* Header */
  .hd { display:flex; justify-content:space-between; align-items:flex-start; }

  .logo-wrap { display:flex; flex-direction:column; gap:4px; }
  .logo {
    font-family:'Oswald', sans-serif; font-weight:700;
    font-size:42px; letter-spacing:10px;
    color: var(--neon);
    text-shadow: 0 0 20px var(--neon), 0 0 60px rgba(0,255,65,0.4);
    animation: logoBlink 5s ease-in-out infinite alternate;
    line-height:1;
  }
  @keyframes logoBlink {
    0%{text-shadow:0 0 15px var(--neon),0 0 40px rgba(0,255,65,0.3)}
    90%{text-shadow:0 0 25px var(--neon),0 0 80px rgba(0,255,65,0.5)}
    92%{text-shadow:none; opacity:0.7}
    94%{text-shadow:0 0 25px var(--neon),0 0 80px rgba(0,255,65,0.5); opacity:1}
    100%{text-shadow:0 0 30px var(--neon),0 0 100px rgba(0,255,65,0.6)}
  }
  .logo-sub {
    font-size:9px; letter-spacing:5px;
    color:rgba(0,255,65,0.4); text-transform:uppercase;
  }

  .hd-right {
    display:flex; flex-direction:column; align-items:flex-end; gap:8px;
    opacity:0; animation:fadeIn .5s ease 1s forwards;
  }
  .sys-badge {
    display:flex; align-items:center; gap:8px;
    padding:6px 14px; border:1px solid var(--border);
    background:rgba(0,26,9,0.8); backdrop-filter:blur(12px);
  }
  .sys-dot {
    width:6px; height:6px; border-radius:50%;
    background:var(--neon); box-shadow:0 0 8px var(--neon);
    animation:sysDot 1s ease-in-out infinite;
  }
  @keyframes sysDot{0%,100%{opacity:1}50%{opacity:.2}}
  .sys-txt { font-size:9px; letter-spacing:4px; color:rgba(0,255,65,0.55); text-transform:uppercase; }
  .sys-coords { font-size:9px; letter-spacing:2px; color:rgba(0,255,65,0.3); }

  /* Center */
  .center {
    position:absolute; left:46px; top:50%; transform:translateY(-50%);
    max-width:380px;
  }
  .eyebrow {
    font-size:9px; letter-spacing:5px; color:rgba(0,255,65,0.45);
    text-transform:uppercase; margin-bottom:16px;
    opacity:0; animation:fadeUp .5s ease .5s forwards;
  }
  .hl {
    font-family:'Oswald', sans-serif; font-weight:700;
    font-size:clamp(34px,4vw,62px);
    line-height:1.05; color:var(--white);
    margin-bottom:18px; letter-spacing:3px;
    opacity:0; animation:fadeUp .5s ease .7s forwards;
    text-shadow:0 0 40px rgba(0,0,0,0.9);
  }
  .hl span {
    color:var(--neon);
    text-shadow:0 0 20px var(--neon), 0 0 40px rgba(0,255,65,0.4);
  }
  .sep { width:44px; height:1px; background:linear-gradient(to right,var(--neon),transparent); margin:18px 0; opacity:0; animation:fadeUp .5s ease .85s forwards; }
  .body-txt {
    font-size:12px; line-height:1.9; color:rgba(0,255,65,0.4);
    letter-spacing:.5px; opacity:0; animation:fadeUp .5s ease .9s forwards;
  }
  .btns {
    display:flex; gap:10px; pointer-events:all;
    margin-top:22px; opacity:0; animation:fadeUp .5s ease 1.05s forwards;
  }
  .btn-neon {
    padding:11px 26px; border:1px solid rgba(0,255,65,0.6);
    background:transparent; position:relative; overflow:hidden;
    font-family:'Share Tech Mono', monospace; font-size:9px;
    letter-spacing:4px; text-transform:uppercase; cursor:none;
    color:var(--neon); transition:color .35s;
  }
  .btn-neon::before {
    content:''; position:absolute; inset:0;
    background:var(--neon); transform:translateX(-101%);
    transition:transform .4s cubic-bezier(.4,0,.2,1);
  }
  .btn-neon:hover::before{transform:translateX(0)}
  .btn-neon:hover{color:var(--abyss)}
  .btn-ghost {
    padding:11px 26px; border:1px solid rgba(0,255,65,0.12);
    background:transparent; font-family:'Share Tech Mono', monospace;
    font-size:9px; letter-spacing:4px; text-transform:uppercase; cursor:none;
    color:rgba(0,255,65,0.25); transition:border-color .3s,color .3s;
  }
  .btn-ghost:hover{border-color:rgba(0,255,65,0.35);color:rgba(0,255,65,0.6)}

  /* Right panel */
  .panel {
    position:absolute; right:46px; top:50%; transform:translateY(-50%);
    display:flex; flex-direction:column; gap:10px; pointer-events:all;
  }
  .card {
    width:210px; padding:13px 16px;
    border:1px solid var(--border);
    background:rgba(0,13,4,0.8); backdrop-filter:blur(16px);
    position:relative; overflow:hidden;
    opacity:0; transform:translateX(16px);
    animation:slideIn .5s ease forwards;
  }
  .card::before {
    content:''; position:absolute; top:0;left:0;
    width:2px;height:100%;
    background:linear-gradient(to bottom,var(--neon),var(--dim));
  }
  .card:nth-child(1){animation-delay:.55s}
  .card:nth-child(2){animation-delay:.7s}
  .card:nth-child(3){animation-delay:.85s}
  .card:nth-child(4){animation-delay:1s}
  .c-lbl { font-size:8px; letter-spacing:3px; color:rgba(0,255,65,0.35); text-transform:uppercase; margin-bottom:6px; }
  .c-val { font-family:'Oswald', sans-serif; font-size:26px; color:var(--white); line-height:1; letter-spacing:1px; }
  .c-val em { font-size:13px; color:var(--neon); font-style:normal; }
  .c-bar { margin-top:7px; height:1px; background:rgba(0,255,65,0.08); overflow:hidden; }
  .c-fill { height:100%; background:linear-gradient(to right,var(--dim),var(--neon)); box-shadow:0 0 6px var(--neon); width:0%; animation:barFill 2s ease forwards; animation-delay:inherit; }
  @keyframes barFill{to{width:var(--w)}}

  /* Bottom */
  .ft { display:flex; justify-content:space-between; align-items:flex-end; }
  .stats { display:flex; gap:36px; opacity:0; animation:fadeUp .5s ease 1.2s forwards; }
  .st { display:flex; flex-direction:column; gap:3px; }
  .st-n { font-family:'Oswald', sans-serif; font-size:28px; color:var(--white); letter-spacing:2px; line-height:1; text-shadow:0 0 15px rgba(0,255,65,0.3); }
  .st-n em { color:var(--neon); font-style:normal; }
  .st-l { font-size:8px; letter-spacing:4px; text-transform:uppercase; color:rgba(0,255,65,0.25); }
  .hint { font-size:8px; letter-spacing:4px; text-transform:uppercase; color:rgba(0,255,65,0.2); animation:breathe 3s ease-in-out infinite; }
  @keyframes breathe{0%,100%{opacity:.2}50%{opacity:.7}}

  /* Tooltip */
  #tip {
    position:fixed; z-index:200; pointer-events:none;
    padding:6px 12px; border:1px solid var(--border);
    background:rgba(0,13,4,0.92); backdrop-filter:blur(12px);
    font-size:9px; letter-spacing:3px; color:var(--neon);
    text-transform:uppercase; opacity:0; transition:opacity .2s; white-space:nowrap;
  }

  @keyframes fadeUp{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:translateY(0)}}
  @keyframes fadeIn{from{opacity:0}to{opacity:1}}
  @keyframes slideIn{to{opacity:1;transform:translateX(0)}}
</style>
</head>
<body>

<canvas id="rain-canvas"></canvas>
<div id="cur"></div>
<div id="cur-cross"></div>
<div id="scan"></div>
<div id="vig"></div>
<div id="glitch"></div>
<div id="tip"></div>

<div id="ui">
  <div class="hd">
    <div class="logo-wrap">
      <div class="logo">MAZE</div>
      <div class="logo-sub">// Labyrinthe Procédural Infini — v∞</div>
    </div>
    <div class="hd-right">
      <div class="sys-badge"><div class="sys-dot"></div><div class="sys-txt">Génération Active</div></div>
      <div class="sys-coords" id="coords">X:0000 Z:0000 · DEPTH:00</div>
    </div>
  </div>

  <div class="center">
    <div class="eyebrow">// simulation.exe — infinite loop</div>
    <h1 class="hl">Il n'y a<br>pas de<br><span>sortie</span></h1>
    <div class="sep"></div>
    <p class="body-txt">Un labyrinthe qui se génère<br>à l'infini devant vous.<br>Chaque mur, une décision.</p>
    <div class="btns">
      <button class="btn-neon">Entrer</button>
      <button class="btn-ghost">Analyser</button>
    </div>
  </div>

  <div class="panel">
    <div class="card">
      <div class="c-lbl">Profondeur</div>
      <div class="c-val" id="m1">—</div>
      <div class="c-bar"><div class="c-fill" style="--w:73%"></div></div>
    </div>
    <div class="card">
      <div class="c-lbl">Murs générés</div>
      <div class="c-val" id="m2">—</div>
      <div class="c-bar"><div class="c-fill" style="--w:89%"></div></div>
    </div>
    <div class="card">
      <div class="c-lbl">Complexité</div>
      <div class="c-val" id="m3">—</div>
      <div class="c-bar"><div class="c-fill" style="--w:62%"></div></div>
    </div>
    <div class="card">
      <div class="c-lbl">Fps</div>
      <div class="c-val" id="m4">—</div>
      <div class="c-bar"><div class="c-fill" style="--w:95%"></div></div>
    </div>
  </div>

  <div class="ft">
    <div class="stats">
      <div class="st"><div class="st-n">∞</div><div class="st-l">Niveaux</div></div>
      <div class="st"><div class="st-n">0<em>%</em></div><div class="st-l">Chance de sortie</div></div>
      <div class="st"><div class="st-n" id="wallCount">0</div><div class="st-l">Murs actifs</div></div>
    </div>
    <div class="hint">scroll · auto-avance</div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ════════════════════════════════════
// MATRIX RAIN (2D canvas overlay)
// ════════════════════════════════════
const rainCanvas = document.getElementById('rain-canvas');
const rc = rainCanvas.getContext('2d');
rainCanvas.width  = innerWidth;
rainCanvas.height = innerHeight;

const cols   = Math.floor(innerWidth / 16);
const drops  = new Array(cols).fill(0).map(() => Math.random() * -50);
const chars  = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨ01アβγδ∞∑∫'.split('');

function drawRain() {
  rc.fillStyle = 'rgba(0,13,4,0.045)';
  rc.fillRect(0, 0, rainCanvas.width, rainCanvas.height);
  rc.font = '13px Share Tech Mono';
  drops.forEach((y, i) => {
    const ch = chars[Math.floor(Math.random() * chars.length)];
    const x  = i * 16;
    rc.fillStyle = Math.random() > 0.97 ? '#e0ffe8' : '#00cc33';
    rc.fillText(ch, x, y * 16);
    if (y * 16 > rainCanvas.height && Math.random() > 0.975) drops[i] = 0;
    else drops[i] += 0.5;
  });
}
setInterval(drawRain, 40);

// ════════════════════════════════════
// THREE.JS SETUP
// ════════════════════════════════════
const W = innerWidth, H = innerHeight;
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(W, H);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.9;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000d04);
scene.fog = new THREE.Fog(0x000d04, 18, 55);

const camera = new THREE.PerspectiveCamera(70, W / H, 0.1, 100);
camera.position.set(0, 2.2, 0);

// ════════════════════════════════════
// MAZE GENERATION (recursive backtracker)
// ════════════════════════════════════
const CELL  = 4;       // cell size in world units
const MSIZE = 24;      // grid dimension (NxN)
const WALL_H = 3.5;
const WALL_T = 0.18;

// Grid: 0 = open, 1 = wall
function generateMaze(size) {
  // Initialize all walls
  const grid = Array.from({ length: size }, () => new Array(size).fill(1));
  const visited = Array.from({ length: size }, () => new Array(size).fill(false));

  function carve(cx, cy) {
    visited[cy][cx] = true;
    grid[cy][cx] = 0;
    const dirs = [[0,-2],[0,2],[-2,0],[2,0]].sort(() => Math.random()-.5);
    for (const [dx, dy] of dirs) {
      const nx = cx + dx, ny = cy + dy;
      if (nx >= 0 && ny >= 0 && nx < size && ny < size && !visited[ny][nx]) {
        grid[cy + dy/2][cx + dx/2] = 0; // carve passage
        carve(nx, ny);
      }
    }
  }
  carve(1, 1);
  return grid;
}

const maze = generateMaze(MSIZE);

// ════════════════════════════════════
// BUILD 3D WALLS
// ════════════════════════════════════
const wallGroup = new THREE.Group();
scene.add(wallGroup);

// Reusable geometry & materials
const wallMatBase = new THREE.MeshStandardMaterial({
  color: 0x001a09,
  emissive: 0x003010,
  emissiveIntensity: 0.15,
  metalness: 0.4,
  roughness: 0.7,
});
const wallMatGlow = new THREE.MeshStandardMaterial({
  color: 0x002a0e,
  emissive: 0x00ff41,
  emissiveIntensity: 0.08,
  metalness: 0.6,
  roughness: 0.4,
  transparent: true,
  opacity: 0.95,
});

const walls = [];
let wallCount = 0;

maze.forEach((row, gy) => {
  row.forEach((cell, gx) => {
    if (cell === 1) {
      const geo = new THREE.BoxGeometry(CELL + WALL_T, WALL_H, CELL + WALL_T);
      const mat = (Math.random() < 0.12) ? wallMatGlow.clone() : wallMatBase.clone();
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(
        (gx - MSIZE / 2) * CELL,
        WALL_H / 2,
        (gy - MSIZE / 2) * CELL
      );
      mesh.castShadow    = true;
      mesh.receiveShadow = true;
      mesh.userData = { gx, gy, glowPhase: Math.random() * Math.PI * 2, isGlow: Math.random() < 0.12 };
      wallGroup.add(mesh);
      walls.push(mesh);
      wallCount++;
    }
  });
});

document.getElementById('wallCount').textContent = wallCount;

// ════════════════════════════════════
// FLOOR
// ════════════════════════════════════
const floorGeo = new THREE.PlaneGeometry(MSIZE * CELL, MSIZE * CELL, MSIZE - 1, MSIZE - 1);
const floorMat = new THREE.MeshStandardMaterial({
  color: 0x000d04,
  emissive: 0x001a09,
  emissiveIntensity: 0.2,
  metalness: 0.3,
  roughness: 0.9,
  wireframe: false,
});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

// Floor grid lines
const gridHelper = new THREE.GridHelper(MSIZE * CELL, MSIZE, 0x002a0e, 0x001508);
gridHelper.position.y = 0.01;
gridHelper.material.transparent = true;
gridHelper.material.opacity = 0.5;
scene.add(gridHelper);

// Ceiling (faint)
const ceilGeo = new THREE.PlaneGeometry(MSIZE * CELL, MSIZE * CELL);
const ceilMat = new THREE.MeshBasicMaterial({ color: 0x000d04, transparent: true, opacity: 0.98 });
const ceil = new THREE.Mesh(ceilGeo, ceilMat);
ceil.rotation.x = Math.PI / 2;
ceil.position.y = WALL_H;
scene.add(ceil);

// ════════════════════════════════════
// NEON EDGE STRIPS on some walls
// ════════════════════════════════════
walls.forEach(w => {
  if (Math.random() < 0.08) {
    const edgeGeo = new THREE.BoxGeometry(CELL + WALL_T + 0.05, 0.04, 0.04);
    const edgeMat = new THREE.MeshBasicMaterial({
      color: 0x00ff41, transparent: true, opacity: 0.7,
    });
    const edge = new THREE.Mesh(edgeGeo, edgeMat);
    const yPos = Math.random() < 0.5 ? 0.3 : WALL_H - 0.3;
    edge.position.copy(w.position);
    edge.position.y = yPos;
    if (Math.random() < 0.5) edge.rotation.y = Math.PI / 2;
    scene.add(edge);
  }
});

// ════════════════════════════════════
// FLOATING PARTICLES in corridors
// ════════════════════════════════════
const SPARKS = 600;
const spkPos = new Float32Array(SPARKS * 3);
const spkVel = [];

for (let i = 0; i < SPARKS; i++) {
  const rx = (Math.random() - 0.5) * MSIZE * CELL;
  const rz = (Math.random() - 0.5) * MSIZE * CELL;
  const gy = Math.floor(rz / CELL + MSIZE / 2);
  const gx = Math.floor(rx / CELL + MSIZE / 2);
  const inMaze = gy >= 0 && gy < MSIZE && gx >= 0 && gx < MSIZE;
  spkPos[i*3]   = rx;
  spkPos[i*3+1] = 0.3 + Math.random() * (WALL_H - 0.5);
  spkPos[i*3+2] = rz;
  spkVel.push({
    x: (Math.random() - 0.5) * 0.015,
    y: (Math.random() - 0.5) * 0.005,
    z: (Math.random() - 0.5) * 0.015,
  });
}

const spkGeo = new THREE.BufferGeometry();
spkGeo.setAttribute('position', new THREE.BufferAttribute(spkPos, 3));
const spkMat = new THREE.PointsMaterial({
  size: 0.06, color: 0x00ff41, transparent: true,
  opacity: 0.55, blending: THREE.AdditiveBlending, depthWrite: false,
});
scene.add(new THREE.Points(spkGeo, spkMat));

// ════════════════════════════════════
// LIGHTS
// ════════════════════════════════════
scene.add(new THREE.AmbientLight(0x001a09, 4));

const camLight = new THREE.PointLight(0x00ff41, 2.5, 12);
camLight.position.copy(camera.position);
scene.add(camLight);

const camLight2 = new THREE.PointLight(0x00cc33, 1.5, 8);
scene.add(camLight2);

// Random corridor lights
for (let i = 0; i < 20; i++) {
  const cx = (Math.floor(Math.random() * MSIZE) - MSIZE/2) * CELL;
  const cz = (Math.floor(Math.random() * MSIZE) - MSIZE/2) * CELL;
  const pl = new THREE.PointLight(0x00ff41, 0.8 + Math.random(), 10);
  pl.position.set(cx, 2, cz);
  scene.add(pl);
}

// ════════════════════════════════════
// AUTO-MOVEMENT PATH
// ════════════════════════════════════
// Find a valid open corridor path through the maze
function findPath() {
  const path = [];
  let cx = 1, cy = 1;
  const visited = new Set();
  let steps = 0;

  while (steps < 400) {
    path.push({ x: (cx - MSIZE/2) * CELL, z: (cy - MSIZE/2) * CELL });
    visited.add(`${cx},${cy}`);
    const dirs = [[0, -2],[0,2],[-2,0],[2,0]].sort(()=>Math.random()-.5);
    let moved = false;
    for (const [dx, dy] of dirs) {
      const nx = cx + dx, ny = cy + dy;
      const mx = cx + dx/2, my = cy + dy/2;
      if (nx > 0 && ny > 0 && nx < MSIZE-1 && ny < MSIZE-1 &&
          maze[my][mx] === 0 && maze[ny][nx] === 0 &&
          !visited.has(`${nx},${ny}`)) {
        cx = nx; cy = ny; moved = true; break;
      }
    }
    if (!moved) break;
    steps++;
  }
  return path;
}

const path    = findPath();
let pathIdx   = 0;
let pathT     = 0;
const AUTO_SPEED = 0.008;

// ════════════════════════════════════
// MOUSE
// ════════════════════════════════════
const mouse   = { x: 0, y: 0 };
const curEl   = document.getElementById('cur');
const crossEl = document.getElementById('cur-cross');
const tipEl   = document.getElementById('tip');

document.addEventListener('mousemove', e => {
  mouse.x = (e.clientX / W) * 2 - 1;
  mouse.y = -(e.clientY / H) * 2 + 1;
  curEl.style.left   = e.clientX + 'px';
  curEl.style.top    = e.clientY + 'px';
  crossEl.style.left = e.clientX + 'px';
  crossEl.style.top  = e.clientY + 'px';
  tipEl.style.left   = (e.clientX + 18) + 'px';
  tipEl.style.top    = (e.clientY - 10) + 'px';
});

// ════════════════════════════════════
// METRICS
// ════════════════════════════════════
let depth = 0;
let wallsGen = wallCount;

[
  { id:'m1', val:depth, fmt: v => `${Math.floor(v)}<em> m</em>` },
  { id:'m2', val:wallCount, fmt: v => `${Math.floor(v)}<em> u</em>` },
  { id:'m3', val:62.4, fmt: v => `${v.toFixed(1)}<em> %</em>` },
  { id:'m4', val:60, fmt: v => `${Math.floor(v)}<em> fps</em>` },
].forEach((m, i) => {
  const el = document.getElementById(m.id);
  let cur = 0;
  setTimeout(() => {
    const step = () => {
      cur += m.val / 50;
      if (cur >= m.val) cur = m.val;
      el.innerHTML = m.fmt(cur);
      if (cur < m.val) requestAnimationFrame(step);
    };
    if (m.val > 0) step();
    else el.innerHTML = m.fmt(0);
  }, 700 + i * 150);
});

// ════════════════════════════════════
// SCROLL — speed boost
// ════════════════════════════════════
let speedMult = 1;
window.addEventListener('wheel', e => {
  speedMult = e.deltaY > 0 ? 3 : 0.3;
  setTimeout(() => speedMult = 1, 600);
});

// Click — teleport to random open cell
document.addEventListener('click', () => {
  pathIdx = Math.floor(Math.random() * path.length);
  pathT   = 0;
});

// ════════════════════════════════════
// ANIMATE
// ════════════════════════════════════
let t = 0;
let frameCount = 0;
let lastFPS = performance.now();

function animate() {
  requestAnimationFrame(animate);
  t += 0.014;
  frameCount++;

  // FPS counter
  const now = performance.now();
  if (frameCount % 20 === 0) {
    const fps = Math.round(20000 / (now - lastFPS));
    document.getElementById('m4').innerHTML = `${fps}<em> fps</em>`;
    lastFPS = now;
  }

  // Auto-advance along path
  pathT += AUTO_SPEED * speedMult;
  if (pathT >= 1) {
    pathT -= 1;
    pathIdx = (pathIdx + 1) % (path.length - 1);
  }

  const cur = path[pathIdx];
  const nxt = path[(pathIdx + 1) % path.length];
  if (!cur || !nxt) { renderer.render(scene, camera); return; }

  // Smooth camera position
  const px = cur.x + (nxt.x - cur.x) * pathT;
  const pz = cur.z + (nxt.z - cur.z) * pathT;

  camera.position.x += (px - camera.position.x) * 0.08;
  camera.position.z += (pz - camera.position.z) * 0.08;
  camera.position.y  = 2.2 + Math.sin(t * 1.2) * 0.08; // subtle head bob

  // Look ahead + mouse influence
  const lookAhead = 0.3;
  const futIdx    = (pathIdx + 2) % path.length;
  const fut       = path[futIdx];
  const lx = nxt.x + (fut ? (fut.x - nxt.x) * lookAhead : 0) + mouse.x * 2.5;
  const lz = nxt.z + (fut ? (fut.z - nxt.z) * lookAhead : 0);
  const ly = camera.position.y + mouse.y * 1.2;
  camera.lookAt(lx, ly, lz);

  // Update camLight
  camLight.position.copy(camera.position);
  camLight2.position.set(camera.position.x, camera.position.y + 1, camera.position.z);
  camLight.intensity  = 2.5 + Math.sin(t * 3) * 0.3;
  camLight2.intensity = 1.5 + Math.cos(t * 2.1) * 0.2;

  // Pulse glowing walls
  walls.forEach(w => {
    if (w.userData.isGlow) {
      w.material.emissiveIntensity = 0.06 + Math.sin(t * 1.5 + w.userData.glowPhase) * 0.05;
    }
  });

  // Particles drift
  const sp = spkGeo.attributes.position.array;
  for (let i = 0; i < SPARKS; i++) {
    sp[i*3]   += spkVel[i].x;
    sp[i*3+1] += spkVel[i].y;
    sp[i*3+2] += spkVel[i].z;
    if (sp[i*3+1] > WALL_H - 0.1 || sp[i*3+1] < 0.1) spkVel[i].y *= -1;
    // Boundary wrap
    const hs = MSIZE * CELL / 2;
    if (Math.abs(sp[i*3]) > hs)   sp[i*3]   *= -0.95;
    if (Math.abs(sp[i*3+2]) > hs) sp[i*3+2] *= -0.95;
  }
  spkGeo.attributes.position.needsUpdate = true;

  // Update metrics
  depth = Math.floor(pathIdx * 0.5 + t * 2) % 999;
  document.getElementById('m1').innerHTML = `${depth}<em> m</em>`;
  wallsGen = wallCount + Math.floor(Math.sin(t) * 5 + t * 0.8) % 50;
  document.getElementById('m2').innerHTML = `${wallsGen}<em> u</em>`;
  document.getElementById('coords').textContent =
    `X:${Math.floor(camera.position.x * 10).toString().padStart(4,'0')} Z:${Math.floor(camera.position.z * 10).toString().padStart(4,'0')} · DEPTH:${String(depth).padStart(2,'0')}`;

  renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', () => {
  const w = innerWidth, h = innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  rainCanvas.width  = w;
  rainCanvas.height = h;
});
</script>
</body>
</html>
