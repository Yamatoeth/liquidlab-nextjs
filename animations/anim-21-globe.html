<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Globe — FORMA</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;700;800&family=DM+Mono:wght@300;400&display=swap');

  :root {
    --bg: #03030a;
    --surface: rgba(255,255,255,0.03);
    --border: rgba(255,255,255,0.06);
    --accent: #4f8eff;
    --accent2: #a78bfa;
    --glow: rgba(79,142,255,0.15);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    width: 100vw; height: 100vh;
    overflow: hidden;
    font-family: 'Syne', sans-serif;
    cursor: none;
  }

  /* Custom cursor */
  #cursor {
    position: fixed; pointer-events: none; z-index: 100;
    width: 8px; height: 8px;
    background: rgba(255,255,255,0.9);
    border-radius: 50%;
    transform: translate(-50%,-50%);
    transition: transform 0.1s, opacity 0.2s;
    mix-blend-mode: difference;
  }
  #cursor-ring {
    position: fixed; pointer-events: none; z-index: 99;
    width: 36px; height: 36px;
    border: 1px solid rgba(255,255,255,0.25);
    border-radius: 50%;
    transform: translate(-50%,-50%);
    transition: transform 0.18s cubic-bezier(0.16,1,0.3,1), width 0.3s, height 0.3s, opacity 0.2s;
  }

  /* Main canvas */
  #mainCanvas {
    position: fixed; inset: 0;
    width: 100%; height: 100%;
  }

  /* UI overlay */
  .ui {
    position: fixed; inset: 0;
    pointer-events: none;
    z-index: 10;
  }

  /* Top bar */
  .topbar {
    position: absolute; top: 32px; left: 40px; right: 40px;
    display: flex; justify-content: space-between; align-items: center;
  }
  .logo {
    font-size: 13px; font-weight: 700; letter-spacing: 0.25em;
    color: rgba(255,255,255,0.9); text-transform: uppercase;
  }
  .logo span { color: var(--accent); }
  .topbar-right {
    display: flex; align-items: center; gap: 24px;
  }
  .status-dot {
    display: flex; align-items: center; gap: 8px;
    font-family: 'DM Mono', monospace; font-size: 11px;
    color: rgba(255,255,255,0.35); letter-spacing: 0.1em;
  }
  .dot-live {
    width: 6px; height: 6px; border-radius: 50%;
    background: #22c55e;
    box-shadow: 0 0 8px #22c55e;
    animation: livePulse 2s ease-in-out infinite;
  }
  @keyframes livePulse { 0%,100% { opacity:1; } 50% { opacity:0.4; } }

  /* Side stats */
  .side-stats {
    position: absolute; right: 40px; top: 50%;
    transform: translateY(-50%);
    display: flex; flex-direction: column; gap: 20px;
  }
  .stat {
    display: flex; flex-direction: column; gap: 4px;
    align-items: flex-end;
  }
  .stat-val {
    font-family: 'DM Mono', monospace;
    font-size: 20px; font-weight: 400;
    color: rgba(255,255,255,0.85);
    letter-spacing: 0.05em;
  }
  .stat-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px; letter-spacing: 0.2em;
    color: rgba(255,255,255,0.2); text-transform: uppercase;
  }
  .stat-bar {
    width: 60px; height: 1px;
    background: rgba(255,255,255,0.06);
    margin-top: 2px; position: relative;
  }
  .stat-bar-fill {
    position: absolute; top: 0; left: 0; height: 100%;
    background: var(--accent);
    box-shadow: 0 0 6px var(--accent);
    transition: width 1s ease;
  }

  /* Bottom info */
  .bottom-bar {
    position: absolute; bottom: 32px; left: 40px; right: 40px;
    display: flex; justify-content: space-between; align-items: flex-end;
  }
  .coords {
    font-family: 'DM Mono', monospace; font-size: 11px;
    color: rgba(255,255,255,0.2); letter-spacing: 0.1em;
    line-height: 1.8;
  }
  .coords b { color: rgba(255,255,255,0.45); }
  .hint-text {
    font-family: 'DM Mono', monospace; font-size: 10px;
    color: rgba(255,255,255,0.18); letter-spacing: 0.2em;
    text-transform: uppercase; text-align: right;
  }

  /* Connection tooltip */
  #tooltip {
    position: fixed; pointer-events: none; z-index: 50;
    background: rgba(5,5,20,0.92);
    border: 1px solid rgba(79,142,255,0.2);
    border-radius: 4px;
    padding: 8px 12px;
    font-family: 'DM Mono', monospace; font-size: 11px;
    color: rgba(255,255,255,0.7); letter-spacing: 0.08em;
    opacity: 0; transition: opacity 0.2s;
    white-space: nowrap;
    backdrop-filter: blur(10px);
  }
</style>
</head>
<body>

<div id="cursor"></div>
<div id="cursor-ring"></div>
<canvas id="mainCanvas"></canvas>

<div class="ui">
  <div class="topbar">
    <div class="logo">FORMA <span>·</span> Globe</div>
    <div class="topbar-right">
      <div class="status-dot"><div class="dot-live"></div>Live · <span id="nodeCount">0</span> nodes</div>
    </div>
  </div>

  <div class="side-stats">
    <div class="stat">
      <div class="stat-val" id="stat1">0</div>
      <div class="stat-label">Connections</div>
      <div class="stat-bar"><div class="stat-bar-fill" id="bar1" style="width:0%"></div></div>
    </div>
    <div class="stat">
      <div class="stat-val" id="stat2">0</div>
      <div class="stat-label">Data / s</div>
      <div class="stat-bar"><div class="stat-bar-fill" id="bar2" style="width:0%"></div></div>
    </div>
    <div class="stat">
      <div class="stat-val" id="stat3">0</div>
      <div class="stat-label">Latency ms</div>
      <div class="stat-bar"><div class="stat-bar-fill" id="bar3" style="width:0%"></div></div>
    </div>
  </div>

  <div class="bottom-bar">
    <div class="coords">
      <div>LAT <b id="lat">0.000°</b> &nbsp; LON <b id="lon">0.000°</b></div>
      <div>ALT <b>408 km</b> &nbsp; INC <b>51.6°</b></div>
    </div>
    <div class="hint-text">Drag to rotate · Scroll to zoom</div>
  </div>
</div>

<div id="tooltip"></div>

<script>
// ─── CANVAS SETUP ──────────────────────────────────────────────────────────────
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
let W, H, cx, cy, globeR;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cx = W / 2; cy = H / 2;
  globeR = Math.min(W, H) * 0.32;
}
resize();
window.addEventListener('resize', resize);

// ─── MOUSE / INTERACTION ────────────────────────────────────────────────────────
const mouse = { x: W/2, y: H/2, ox: W/2, oy: H/2 };
const cursorEl = document.getElementById('cursor');
const cursorRing = document.getElementById('cursor-ring');

window.addEventListener('mousemove', e => {
  mouse.x = e.clientX; mouse.y = e.clientY;
  cursorEl.style.left = e.clientX + 'px';
  cursorEl.style.top = e.clientY + 'px';
  cursorRing.style.left = e.clientX + 'px';
  cursorRing.style.top = e.clientY + 'px';
});

// Drag to rotate
let dragging = false, lastDX = 0, lastDY = 0;
let rotY = -0.4, rotX = 0.2;
let velY = 0.0015, velX = 0;

canvas.addEventListener('mousedown', e => {
  dragging = true; lastDX = e.clientX; lastDY = e.clientY;
  velY = 0; velX = 0;
});
window.addEventListener('mousemove', e => {
  if (!dragging) return;
  velY = (e.clientX - lastDX) * 0.004;
  velX = (e.clientY - lastDY) * 0.004;
  rotY += velY; rotX += velX;
  rotX = Math.max(-Math.PI/2.2, Math.min(Math.PI/2.2, rotX));
  lastDX = e.clientX; lastDY = e.clientY;
});
window.addEventListener('mouseup', () => dragging = false);

// Scroll zoom
let zoom = 1;
window.addEventListener('wheel', e => {
  zoom = Math.max(0.6, Math.min(1.8, zoom - e.deltaY * 0.001));
});

// Touch
window.addEventListener('touchstart', e => { dragging=true; lastDX=e.touches[0].clientX; lastDY=e.touches[0].clientY; velY=velX=0; }, {passive:true});
window.addEventListener('touchmove', e => {
  if(!dragging) return;
  velY=(e.touches[0].clientX-lastDX)*0.004; velX=(e.touches[0].clientY-lastDY)*0.004;
  rotY+=velY; rotX+=velX;
  rotX=Math.max(-Math.PI/2.2,Math.min(Math.PI/2.2,rotX));
  lastDX=e.touches[0].clientX; lastDY=e.touches[0].clientY;
}, {passive:true});
window.addEventListener('touchend', () => dragging=false);

// ─── 3D MATH ────────────────────────────────────────────────────────────────────
function latLonToXYZ(lat, lon) {
  const phi = (90 - lat) * Math.PI / 180;
  const theta = (lon + 180) * Math.PI / 180;
  return {
    x: -Math.sin(phi) * Math.cos(theta),
    y: Math.cos(phi),
    z: Math.sin(phi) * Math.sin(theta),
  };
}

function rotatePoint(p, rx, ry) {
  // Rotate Y
  let x = p.x * Math.cos(ry) + p.z * Math.sin(ry);
  let z = -p.x * Math.sin(ry) + p.z * Math.cos(ry);
  let y = p.y;
  // Rotate X
  let y2 = y * Math.cos(rx) - z * Math.sin(rx);
  let z2 = y * Math.sin(rx) + z * Math.cos(rx);
  return { x, y: y2, z: z2 };
}

function project(p) {
  const r = globeR * zoom;
  const fov = 3.5;
  const scale = fov / (fov + p.z);
  return {
    x: cx + p.x * r * scale,
    y: cy - p.y * r * scale,
    z: p.z,
    scale,
    visible: p.z > -0.3,
  };
}

// ─── WORLD DATA ─────────────────────────────────────────────────────────────────
const CITIES = [
  { name: 'New York',    lat: 40.7,   lon: -74.0,  size: 1.2 },
  { name: 'London',      lat: 51.5,   lon: -0.1,   size: 1.2 },
  { name: 'Tokyo',       lat: 35.7,   lon: 139.7,  size: 1.2 },
  { name: 'Paris',       lat: 48.9,   lon: 2.3,    size: 1.0 },
  { name: 'Singapore',   lat: 1.3,    lon: 103.8,  size: 1.0 },
  { name: 'São Paulo',   lat: -23.5,  lon: -46.6,  size: 0.9 },
  { name: 'Sydney',      lat: -33.9,  lon: 151.2,  size: 0.9 },
  { name: 'Dubai',       lat: 25.2,   lon: 55.3,   size: 1.0 },
  { name: 'Mumbai',      lat: 19.1,   lon: 72.9,   size: 0.9 },
  { name: 'Toronto',     lat: 43.7,   lon: -79.4,  size: 0.8 },
  { name: 'Berlin',      lat: 52.5,   lon: 13.4,   size: 0.8 },
  { name: 'Seoul',       lat: 37.6,   lon: 127.0,  size: 0.9 },
  { name: 'Johannesburg',lat: -26.2,  lon: 28.0,   size: 0.7 },
  { name: 'Mexico City', lat: 19.4,   lon: -99.1,  size: 0.8 },
  { name: 'Shanghai',    lat: 31.2,   lon: 121.5,  size: 1.0 },
  { name: 'Amsterdam',   lat: 52.4,   lon: 4.9,    size: 0.8 },
  { name: 'Chicago',     lat: 41.9,   lon: -87.6,  size: 0.8 },
  { name: 'Hong Kong',   lat: 22.3,   lon: 114.2,  size: 0.9 },
  { name: 'Stockholm',   lat: 59.3,   lon: 18.1,   size: 0.7 },
  { name: 'Nairobi',     lat: -1.3,   lon: 36.8,   size: 0.7 },
  { name: 'Los Angeles', lat: 34.0,   lon: -118.2, size: 1.0 },
  { name: 'Moscow',      lat: 55.8,   lon: 37.6,   size: 0.9 },
];

// Active connections (pairs of city indices)
let connections = [];
let activeArcs = [];

function buildConnections() {
  connections = [];
  const n = CITIES.length;
  for (let i = 0; i < n; i++) {
    const numConns = 2 + Math.floor(Math.random() * 3);
    for (let j = 0; j < numConns; j++) {
      const target = Math.floor(Math.random() * n);
      if (target !== i) connections.push([i, target]);
    }
  }
}
buildConnections();

// ─── ANIMATED ARCS ──────────────────────────────────────────────────────────────
class Arc {
  constructor(fromIdx, toIdx) {
    this.from = fromIdx;
    this.to = toIdx;
    this.progress = 0;
    this.speed = 0.004 + Math.random() * 0.006;
    this.life = 1;
    this.maxLife = 120 + Math.floor(Math.random() * 80);
    this.age = 0;
    this.color = Math.random() > 0.5 ? '#4f8eff' : '#a78bfa';
    this.trail = 0.3 + Math.random() * 0.4;
  }
  update() {
    this.progress = Math.min(1, this.progress + this.speed);
    this.age++;
    if (this.age > this.maxLife) this.life -= 0.05;
    return this.life > 0;
  }
  getBezierPoint(t) {
    const A = latLonToXYZ(CITIES[this.from].lat, CITIES[this.from].lon);
    const B = latLonToXYZ(CITIES[this.to].lat, CITIES[this.to].lon);
    // Control point: lift above the sphere surface
    const mid = {
      x: (A.x + B.x) / 2,
      y: (A.y + B.y) / 2,
      z: (A.z + B.z) / 2,
    };
    const len = Math.sqrt(mid.x*mid.x + mid.y*mid.y + mid.z*mid.z);
    const lift = 1.35 + Math.sqrt((A.x-B.x)**2+(A.y-B.y)**2+(A.z-B.z)**2) * 0.3;
    const C = { x: mid.x/len*lift, y: mid.y/len*lift, z: mid.z/len*lift };
    // Quadratic bezier
    const u = 1 - t;
    return {
      x: u*u*A.x + 2*u*t*C.x + t*t*B.x,
      y: u*u*A.y + 2*u*t*C.y + t*t*B.y,
      z: u*u*A.z + 2*u*t*C.z + t*t*B.z,
    };
  }
}

// Spawn arcs periodically
let arcTimer = 0;
function spawnArc() {
  if (activeArcs.length < 18 && connections.length > 0) {
    const conn = connections[Math.floor(Math.random() * connections.length)];
    activeArcs.push(new Arc(conn[0], conn[1]));
  }
}

// ─── GRID DOTS ON SPHERE ────────────────────────────────────────────────────────
const GRID_DOTS = [];
(function buildGrid() {
  const rows = 28, cols = 56;
  for (let r = 0; r <= rows; r++) {
    const lat = -90 + (r / rows) * 180;
    for (let c = 0; c < cols; c++) {
      const lon = -180 + (c / cols) * 360;
      const isOcean = isOceanPoint(lat, lon);
      GRID_DOTS.push({ lat, lon, ocean: isOcean });
    }
  }
})();

function isOceanPoint(lat, lon) {
  // Rough continental masks
  // North America
  if (lat>20&&lat<75&&lon>-140&&lon<-55) return false;
  // South America
  if (lat>-55&&lat<12&&lon>-82&&lon<-34) return false;
  // Europe
  if (lat>35&&lat<72&&lon>-10&&lon<40) return false;
  // Africa
  if (lat>-35&&lat<38&&lon>-18&&lon<52) return false;
  // Asia
  if (lat>10&&lat<75&&lon>40&&lon<145) return false;
  // SE Asia
  if (lat>-10&&lat<25&&lon>95&&lon<145) return false;
  // Australia
  if (lat>-40&&lat<-10&&lon>114&&lon<154) return false;
  // Russia
  if (lat>50&&lat<75&&lon>50&&lon<140) return false;
  return true;
}

// ─── ORBITAL RING ──────────────────────────────────────────────────────────────
class OrbitalParticle {
  constructor(ringIdx) {
    this.angle = Math.random() * Math.PI * 2;
    this.speed = (0.004 + Math.random() * 0.003) * (Math.random() > 0.5 ? 1 : -1);
    this.ringIdx = ringIdx;
    this.size = 1.5 + Math.random() * 2;
    this.brightness = 0.4 + Math.random() * 0.6;
    this.trail = [];
  }
  update() {
    this.angle += this.speed;
    const rings = [
      { tilt: 15 * Math.PI/180, radius: 1.22 },
      { tilt: -28 * Math.PI/180, radius: 1.38 },
      { tilt: 52 * Math.PI/180, radius: 1.55 },
    ];
    const ring = rings[this.ringIdx];
    const rx = Math.cos(this.angle) * ring.radius;
    const ry = Math.sin(this.angle) * ring.radius * Math.cos(ring.tilt);
    const rz = Math.sin(this.angle) * ring.radius * Math.sin(ring.tilt) * 0.5;
    this.pos = { x: rx, y: ry, z: rz };
    this.trail.push({ ...this.pos });
    if (this.trail.length > 20) this.trail.shift();
  }
}

const orbitals = [
  ...Array.from({ length: 4 }, () => new OrbitalParticle(0)),
  ...Array.from({ length: 3 }, () => new OrbitalParticle(1)),
  ...Array.from({ length: 3 }, () => new OrbitalParticle(2)),
];

// ─── RENDERING ──────────────────────────────────────────────────────────────────
let time = 0;
let frame = 0;

function drawGlobe() {
  const r = globeR * zoom;

  // ── ATMOSPHERE (outer glow) ──
  for (let i = 4; i >= 0; i--) {
    const layers = [
      { dr: 0.18, alpha: 0.03, color: '#3b6fd4' },
      { dr: 0.12, alpha: 0.05, color: '#4477e8' },
      { dr: 0.07, alpha: 0.07, color: '#5588ff' },
      { dr: 0.04, alpha: 0.09, color: '#6699ff' },
      { dr: 0.01, alpha: 0.05, color: '#aaccff' },
    ];
    const l = layers[i];
    const grad = ctx.createRadialGradient(cx, cy, r*(1-l.dr*0.5), cx, cy, r*(1+l.dr));
    grad.addColorStop(0, `rgba(80,136,255,0)`);
    grad.addColorStop(0.6, `rgba(80,136,255,${l.alpha*0.5})`);
    grad.addColorStop(1, `rgba(60,100,220,${l.alpha})`);
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(cx, cy, r*(1+l.dr), 0, Math.PI*2); ctx.fill();
  }

  // ── GLOBE BASE ──
  const baseGrad = ctx.createRadialGradient(cx-r*0.25, cy-r*0.2, 0, cx, cy, r*1.1);
  baseGrad.addColorStop(0,   '#0a1535');
  baseGrad.addColorStop(0.4, '#06101e');
  baseGrad.addColorStop(0.8, '#040c18');
  baseGrad.addColorStop(1,   '#020810');
  ctx.fillStyle = baseGrad;
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();

  // ── SPECULAR HIGHLIGHT ──
  const specGrad = ctx.createRadialGradient(cx-r*0.35, cy-r*0.3, 0, cx-r*0.1, cy-r*0.1, r*0.8);
  specGrad.addColorStop(0, 'rgba(140,180,255,0.06)');
  specGrad.addColorStop(0.5, 'rgba(100,150,255,0.02)');
  specGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = specGrad;
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();

  // Clip to globe
  ctx.save();
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.clip();

  // ── GRID DOTS (land = bright, ocean = dim) ──
  GRID_DOTS.forEach(dot => {
    const p3d = latLonToXYZ(dot.lat, dot.lon);
    const rot = rotatePoint(p3d, rotX, rotY);
    if (rot.z < 0.02) return; // backface
    const proj = project(rot);

    const alpha = Math.max(0, (rot.z - 0.02) / 0.98);
    const size = dot.ocean ? 0.8 : 1.4;
    const brightness = dot.ocean ? 0.12 : 0.4;

    if (dot.ocean) {
      ctx.fillStyle = `rgba(40,80,160,${alpha * brightness})`;
    } else {
      ctx.fillStyle = `rgba(100,160,255,${alpha * brightness})`;
    }
    ctx.beginPath();
    ctx.arc(proj.x, proj.y, size * proj.scale, 0, Math.PI*2);
    ctx.fill();
  });

  // ── LATITUDE / LONGITUDE GRID LINES ──
  ctx.lineWidth = 0.3;
  ctx.strokeStyle = 'rgba(60,100,200,0.08)';

  // Latitude lines
  for (let lat = -60; lat <= 60; lat += 30) {
    ctx.beginPath();
    let first = true;
    for (let lon = -180; lon <= 180; lon += 4) {
      const p = latLonToXYZ(lat, lon);
      const rot = rotatePoint(p, rotX, rotY);
      if (rot.z < 0) { first = true; continue; }
      const pr = project(rot);
      if (first) { ctx.moveTo(pr.x, pr.y); first = false; }
      else ctx.lineTo(pr.x, pr.y);
    }
    ctx.stroke();
  }
  // Longitude lines
  for (let lon = -180; lon < 180; lon += 30) {
    ctx.beginPath();
    let first = true;
    for (let lat = -90; lat <= 90; lat += 3) {
      const p = latLonToXYZ(lat, lon);
      const rot = rotatePoint(p, rotX, rotY);
      if (rot.z < 0) { first = true; continue; }
      const pr = project(rot);
      if (first) { ctx.moveTo(pr.x, pr.y); first = false; }
      else ctx.lineTo(pr.x, pr.y);
    }
    ctx.stroke();
  }

  ctx.restore(); // end globe clip

  // ── STATIC CONNECTION LINES (dim, on-surface) ──
  connections.slice(0, 14).forEach(([i, j]) => {
    const A = rotatePoint(latLonToXYZ(CITIES[i].lat, CITIES[i].lon), rotX, rotY);
    const B = rotatePoint(latLonToXYZ(CITIES[j].lat, CITIES[j].lon), rotX, rotY);
    if (A.z < 0 || B.z < 0) return;
    const pA = project(A), pB = project(B);
    ctx.beginPath(); ctx.moveTo(pA.x, pA.y); ctx.lineTo(pB.x, pB.y);
    ctx.strokeStyle = 'rgba(60,120,220,0.07)';
    ctx.lineWidth = 0.5; ctx.stroke();
  });
}

function drawArcs() {
  activeArcs.forEach(arc => {
    const STEPS = 50;
    const tailStart = Math.max(0, arc.progress - arc.trail);

    // Draw arc tail
    ctx.beginPath();
    let first = true;
    let lastVisible = false;

    for (let s = 0; s <= STEPS; s++) {
      const t = tailStart + (arc.progress - tailStart) * (s / STEPS);
      const p3d = arc.getBezierPoint(t);
      const rot = rotatePoint(p3d, rotX, rotY);
      const proj = project(rot);
      const segAlpha = (s / STEPS);

      if (rot.z < -0.1) { first = true; lastVisible = false; continue; }

      if (first) { ctx.moveTo(proj.x, proj.y); first = false; }
      else ctx.lineTo(proj.x, proj.y);
      lastVisible = true;
    }

    const alpha = Math.min(arc.life, arc.progress * 2);
    ctx.strokeStyle = arc.color === '#4f8eff'
      ? `rgba(79,142,255,${alpha * 0.6})`
      : `rgba(167,139,250,${alpha * 0.6})`;
    ctx.lineWidth = 1.5;
    ctx.shadowColor = arc.color;
    ctx.shadowBlur = 6;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Leading dot
    const headP = arc.getBezierPoint(arc.progress);
    const headRot = rotatePoint(headP, rotX, rotY);
    if (headRot.z > 0) {
      const headProj = project(headRot);
      ctx.beginPath();
      ctx.arc(headProj.x, headProj.y, 2.5, 0, Math.PI*2);
      ctx.fillStyle = arc.color;
      ctx.shadowColor = arc.color; ctx.shadowBlur = 10;
      ctx.fill(); ctx.shadowBlur = 0;
    }
  });
}

function drawCityNodes() {
  CITIES.forEach((city, i) => {
    const p3d = latLonToXYZ(city.lat, city.lon);
    const rot = rotatePoint(p3d, rotX, rotY);
    if (rot.z < 0.05) return;
    const proj = project(rot);
    const alpha = Math.min(1, (rot.z - 0.05) / 0.4);

    // Outer pulse ring
    const pulse = 0.5 + 0.5 * Math.sin(time * 2 + i * 0.8);
    ctx.beginPath();
    ctx.arc(proj.x, proj.y, (4 + pulse * 4) * proj.scale * city.size, 0, Math.PI*2);
    ctx.strokeStyle = `rgba(79,142,255,${alpha * 0.2 * pulse})`;
    ctx.lineWidth = 0.8;
    ctx.stroke();

    // Middle ring
    ctx.beginPath();
    ctx.arc(proj.x, proj.y, 3 * proj.scale * city.size, 0, Math.PI*2);
    ctx.strokeStyle = `rgba(120,180,255,${alpha * 0.4})`;
    ctx.lineWidth = 1;
    ctx.stroke();

    // Core dot
    ctx.beginPath();
    ctx.arc(proj.x, proj.y, 2 * proj.scale * city.size, 0, Math.PI*2);
    ctx.fillStyle = `rgba(180,210,255,${alpha * 0.9})`;
    ctx.shadowColor = '#4f8eff'; ctx.shadowBlur = 8 * alpha;
    ctx.fill(); ctx.shadowBlur = 0;
  });
}

function drawOrbitals() {
  const RING_COLORS = ['#4f8eff','#a78bfa','#34d399'];
  const RING_RADII  = [1.22, 1.38, 1.55];
  const RING_TILTS  = [15, -28, 52];

  // Draw orbital rings (ellipses)
  RING_RADII.forEach((rad, ri) => {
    const tilt = RING_TILTS[ri] * Math.PI / 180;
    const r = globeR * zoom * rad;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(tilt * 0.3);
    ctx.beginPath();
    ctx.ellipse(0, 0, r, r * Math.cos(tilt), 0, 0, Math.PI*2);
    ctx.strokeStyle = `rgba(${ri===0?'79,142,255':ri===1?'167,139,250':'52,211,153'},0.08)`;
    ctx.lineWidth = 1; ctx.setLineDash([4,6]);
    ctx.stroke(); ctx.setLineDash([]);
    ctx.restore();
  });

  // Draw orbital particles with trails
  orbitals.forEach((orb, oi) => {
    orb.update();
    const color = RING_COLORS[orb.ringIdx];
    const [cr, cg, cb] = color === '#4f8eff' ? [79,142,255] : color === '#a78bfa' ? [167,139,250] : [52,211,153];

    // Trail
    orb.trail.forEach((tp, ti) => {
      const rot = rotatePoint(tp, rotX, rotY);
      const proj = project(rot);
      if (rot.z < -0.5) return;
      const alpha = (ti / orb.trail.length) * 0.4 * orb.brightness;
      const size = (ti / orb.trail.length) * 1.5 * proj.scale;
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, Math.max(0.3, size), 0, Math.PI*2);
      ctx.fillStyle = `rgba(${cr},${cg},${cb},${alpha})`;
      ctx.fill();
    });

    // Head
    const rot = rotatePoint(orb.pos, rotX, rotY);
    const proj = project(rot);
    if (rot.z > -0.3) {
      const headAlpha = (rot.z + 0.3) / 1.3 * orb.brightness;
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, orb.size * proj.scale, 0, Math.PI*2);
      ctx.fillStyle = `rgba(${cr},${cg},${cb},${headAlpha})`;
      ctx.shadowColor = color; ctx.shadowBlur = 6;
      ctx.fill(); ctx.shadowBlur = 0;
    }
  });
}

function drawGlobeRim() {
  // Rim light effect
  const r = globeR * zoom;
  const rimGrad = ctx.createRadialGradient(cx, cy, r * 0.88, cx, cy, r * 1.02);
  rimGrad.addColorStop(0, 'rgba(40,90,220,0)');
  rimGrad.addColorStop(0.6, 'rgba(50,100,230,0.04)');
  rimGrad.addColorStop(1, 'rgba(80,140,255,0.12)');
  ctx.fillStyle = rimGrad;
  ctx.beginPath(); ctx.arc(cx, cy, r*1.02, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx, cy, r*0.88, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.fill();
}

// ─── STAR FIELD ─────────────────────────────────────────────────────────────────
const STARS = Array.from({ length: 200 }, () => ({
  x: Math.random(), y: Math.random(),
  r: 0.3 + Math.random() * 1.2,
  alpha: 0.1 + Math.random() * 0.5,
  twinkle: Math.random() * Math.PI * 2,
  speed: 0.005 + Math.random() * 0.015,
}));

function drawStars() {
  STARS.forEach(s => {
    s.twinkle += s.speed;
    const a = s.alpha * (0.6 + 0.4 * Math.sin(s.twinkle));
    ctx.beginPath();
    ctx.arc(s.x * W, s.y * H, s.r, 0, Math.PI*2);
    ctx.fillStyle = `rgba(200,215,255,${a})`;
    ctx.fill();
  });
}

// ─── UI UPDATE ──────────────────────────────────────────────────────────────────
let statTimer = 0;
function updateUI() {
  statTimer++;
  if (statTimer % 60 === 0) {
    document.getElementById('stat1').textContent = (1800 + Math.floor(Math.random()*400)).toLocaleString();
    document.getElementById('stat2').textContent = (2.1 + Math.random()*0.8).toFixed(1) + ' TB';
    document.getElementById('stat3').textContent = (18 + Math.floor(Math.random()*12)) + ' ms';
    document.getElementById('bar1').style.width = (55+Math.random()*30)+'%';
    document.getElementById('bar2').style.width = (40+Math.random()*40)+'%';
    document.getElementById('bar3').style.width = (20+Math.random()*30)+'%';
    document.getElementById('nodeCount').textContent = CITIES.length;
  }

  // Coords from rotation
  const latVal = (-rotX * 180 / Math.PI).toFixed(3);
  const lonVal = ((rotY * 180 / Math.PI) % 360).toFixed(3);
  document.getElementById('lat').textContent = latVal + '°';
  document.getElementById('lon').textContent = lonVal + '°';
}

// ─── MAIN LOOP ──────────────────────────────────────────────────────────────────
function render() {
  time += 0.016;
  frame++;

  // Auto rotation inertia
  if (!dragging) {
    velY *= 0.96; velX *= 0.95;
    rotY += velY + 0.0015;
    rotX += velX;
    rotX = Math.max(-Math.PI/2.2, Math.min(Math.PI/2.2, rotX));
  }

  // Spawn arcs
  arcTimer++;
  if (arcTimer % 40 === 0) spawnArc();
  activeArcs = activeArcs.filter(a => a.update());

  // Clear
  ctx.clearRect(0, 0, W, H);

  // Background
  const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(W,H)*0.8);
  bgGrad.addColorStop(0, '#05091a');
  bgGrad.addColorStop(0.5, '#030712');
  bgGrad.addColorStop(1, '#020408');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, W, H);

  drawStars();
  drawGlobe();
  drawArcs();
  drawCityNodes();
  drawOrbitals();
  drawGlobeRim();
  updateUI();

  requestAnimationFrame(render);
}

// Initial stat values
document.getElementById('stat1').textContent = '1,924';
document.getElementById('stat2').textContent = '2.4 TB';
document.getElementById('stat3').textContent = '24 ms';
document.getElementById('bar1').style.width = '72%';
document.getElementById('bar2').style.width = '58%';
document.getElementById('bar3').style.width = '28%';
document.getElementById('nodeCount').textContent = CITIES.length;

render();
</script>
</body>
</html>
