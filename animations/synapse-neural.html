<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SYNAPSE — Neural Network</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=DM+Mono:ital,wght@0,300;0,400;1,300&family=Bebas+Neue&family=DM+Sans:wght@200;300;400&display=swap');

  *, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }

  :root {
    --ice:    #e8f4ff;
    --frost:  #b8d4f0;
    --cyan:   #7ec8e3;
    --blue:   #3a8fb5;
    --deep:   #0d1f2d;
    --abyss:  #060d14;
    --white:  #f0faff;
    --glow:   rgba(126,200,227,0.4);
    --border: rgba(184,212,240,0.15);
  }

  html, body {
    width:100%; height:100%;
    background: var(--abyss);
    overflow:hidden; cursor:none;
    font-family: 'DM Sans', sans-serif;
  }

  canvas { display:block; position:fixed; inset:0; z-index:0; }

  /* Cursor */
  #cur {
    position:fixed; pointer-events:none; z-index:9999;
    width:5px; height:5px; border-radius:50%;
    background: var(--white);
    transform:translate(-50%,-50%);
    box-shadow: 0 0 8px var(--ice), 0 0 20px var(--glow);
    mix-blend-mode: screen;
  }
  #cur-ring {
    position:fixed; pointer-events:none; z-index:9998;
    width:32px; height:32px; border-radius:50%;
    border:1px solid rgba(184,212,240,0.35);
    transform:translate(-50%,-50%);
    transition: width .3s, height .3s, border-color .3s;
    backdrop-filter: blur(0px);
  }
  #cur-ring.active {
    width:52px; height:52px;
    border-color:rgba(240,250,255,0.8);
    box-shadow:0 0 20px rgba(126,200,227,0.3);
  }

  /* Vignette */
  #vig {
    position:fixed; inset:0; pointer-events:none; z-index:4;
    background: radial-gradient(ellipse at 55% 50%, transparent 25%, rgba(6,13,20,0.88) 100%);
  }

  /* Frosted glass scanlines */
  #scan {
    position:fixed; inset:0; pointer-events:none; z-index:5;
    background: repeating-linear-gradient(
      0deg, transparent, transparent 3px,
      rgba(184,212,240,0.018) 3px, rgba(184,212,240,0.018) 4px
    );
  }

  /* UI */
  #ui {
    position:fixed; inset:0; z-index:10; pointer-events:none;
    padding:40px 50px;
    display:flex; flex-direction:column; justify-content:space-between;
  }

  /* Header */
  .hd { display:flex; justify-content:space-between; align-items:flex-start; }

  .logo {
    font-family:'Bebas Neue', sans-serif;
    font-size:44px; letter-spacing:12px;
    color: var(--white);
    text-shadow: 0 0 30px rgba(126,200,227,0.5), 0 0 80px rgba(126,200,227,0.2);
    animation: icePulse 4s ease-in-out infinite alternate;
    line-height:1;
  }
  @keyframes icePulse {
    from { text-shadow: 0 0 20px rgba(126,200,227,0.3), 0 0 60px rgba(126,200,227,0.1); }
    to   { text-shadow: 0 0 40px rgba(184,212,240,0.7), 0 0 100px rgba(126,200,227,0.3); }
  }
  .logo-tag {
    font-family:'DM Mono', monospace; font-size:9px;
    letter-spacing:5px; color:rgba(126,200,227,0.45);
    text-transform:uppercase; margin-top:5px;
  }

  .hd-right {
    display:flex; flex-direction:column; align-items:flex-end; gap:10px;
    opacity:0; animation:fadeIn .6s ease 1s forwards;
  }
  .neural-status {
    display:flex; align-items:center; gap:10px;
    padding:7px 18px;
    border:1px solid var(--border);
    background:rgba(13,31,45,0.7);
    backdrop-filter:blur(16px);
  }
  .pulse-dot {
    width:7px; height:7px; border-radius:50%;
    background: var(--cyan);
    box-shadow: 0 0 10px var(--cyan);
    animation: pd 1.4s ease-in-out infinite;
  }
  @keyframes pd { 0%,100%{transform:scale(1);opacity:1} 50%{transform:scale(1.5);opacity:.5} }
  .status-txt {
    font-family:'DM Mono', monospace; font-size:9px;
    letter-spacing:4px; color:rgba(184,212,240,0.55);
    text-transform:uppercase;
  }
  .node-count {
    font-family:'DM Mono', monospace; font-size:10px;
    letter-spacing:3px; color:rgba(126,200,227,0.35);
  }

  /* Center */
  .center {
    position:absolute; left:50px; top:50%; transform:translateY(-50%);
    max-width:380px;
  }
  .eyebrow {
    font-family:'DM Mono', monospace; font-size:9px;
    letter-spacing:5px; color:rgba(126,200,227,0.5);
    text-transform:uppercase; margin-bottom:18px;
    opacity:0; animation:fadeUp .6s ease .5s forwards;
  }
  .hl {
    font-family:'Bebas Neue', sans-serif;
    font-size:clamp(38px,4.5vw,68px);
    line-height:1.0; color: var(--white);
    margin-bottom:20px; letter-spacing:3px;
    opacity:0; animation:fadeUp .6s ease .7s forwards;
    text-shadow:0 2px 40px rgba(0,0,0,0.9);
  }
  .hl span {
    background:linear-gradient(135deg, var(--white), var(--frost), var(--cyan));
    -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
  }
  .body {
    font-size:14px; line-height:1.85; font-weight:300;
    color:rgba(224,240,255,0.4); letter-spacing:.3px;
    opacity:0; animation:fadeUp .6s ease .9s forwards;
    font-style:italic;
  }
  .sep {
    width:48px; height:1px; margin:22px 0;
    background:linear-gradient(to right, var(--cyan), transparent);
    opacity:0; animation:fadeUp .6s ease 1s forwards;
  }
  .btns {
    display:flex; gap:12px; pointer-events:all;
    opacity:0; animation:fadeUp .6s ease 1.1s forwards;
  }
  .btn-ice {
    padding:12px 28px;
    border:1px solid rgba(126,200,227,0.45);
    background:transparent; position:relative; overflow:hidden;
    font-family:'DM Mono', monospace; font-size:9px;
    letter-spacing:4px; text-transform:uppercase; cursor:none;
    color: var(--frost); transition:color .35s;
  }
  .btn-ice::before {
    content:''; position:absolute; inset:0;
    background:linear-gradient(135deg, rgba(126,200,227,0.8), rgba(184,212,240,0.6));
    transform:translateX(-101%);
    transition:transform .4s cubic-bezier(.4,0,.2,1);
  }
  .btn-ice:hover::before { transform:translateX(0); }
  .btn-ice:hover { color: var(--abyss); }
  .btn-line {
    padding:12px 28px;
    border:1px solid rgba(184,212,240,0.12);
    background:transparent;
    font-family:'DM Mono', monospace; font-size:9px;
    letter-spacing:4px; text-transform:uppercase; cursor:none;
    color:rgba(184,212,240,0.3);
    transition:border-color .3s, color .3s;
  }
  .btn-line:hover { border-color:rgba(184,212,240,0.3); color:rgba(184,212,240,0.6); }

  /* Right panel — live metrics */
  .panel {
    position:absolute; right:50px; top:50%; transform:translateY(-50%);
    display:flex; flex-direction:column; gap:12px;
    pointer-events:all;
  }
  .metric {
    width:200px; padding:14px 18px;
    border:1px solid var(--border);
    background:rgba(6,13,20,0.75);
    backdrop-filter:blur(20px);
    position:relative; overflow:hidden;
    opacity:0; transform:translateX(18px);
    animation:slideIn .5s ease forwards;
  }
  .metric::after {
    content:''; position:absolute;
    top:0; left:0; width:2px; height:100%;
    background:linear-gradient(to bottom, var(--cyan), var(--blue));
  }
  .metric:nth-child(1){animation-delay:.6s}
  .metric:nth-child(2){animation-delay:.75s}
  .metric:nth-child(3){animation-delay:.9s}
  .metric:nth-child(4){animation-delay:1.05s}

  .m-label {
    font-family:'DM Mono', monospace; font-size:8px;
    letter-spacing:3px; color:rgba(126,200,227,0.4);
    text-transform:uppercase; margin-bottom:7px;
  }
  .m-val {
    font-family:'Bebas Neue', sans-serif; font-size:28px;
    color: var(--white); line-height:1; letter-spacing:2px;
  }
  .m-val .u { font-size:14px; color: var(--cyan); letter-spacing:1px; }
  .m-bar {
    margin-top:8px; height:1px;
    background:rgba(126,200,227,0.1); overflow:hidden;
  }
  .m-fill {
    height:100%;
    background:linear-gradient(to right, var(--blue), var(--cyan), var(--frost));
    box-shadow:0 0 6px var(--cyan);
    width:0%; animation:barFill 2s ease forwards;
    animation-delay:inherit;
  }
  @keyframes barFill { to { width:var(--w); } }

  /* Bottom */
  .ft { display:flex; justify-content:space-between; align-items:flex-end; }
  .stats { display:flex; gap:40px; opacity:0; animation:fadeUp .6s ease 1.3s forwards; }
  .s { display:flex; flex-direction:column; gap:3px; }
  .s-n {
    font-family:'Bebas Neue', sans-serif; font-size:30px;
    color: var(--white); letter-spacing:2px; line-height:1;
    text-shadow:0 0 20px rgba(126,200,227,0.3);
  }
  .s-n em { color: var(--cyan); font-style:normal; }
  .s-l {
    font-family:'DM Mono', monospace; font-size:8px;
    letter-spacing:4px; text-transform:uppercase;
    color:rgba(126,200,227,0.3);
  }
  .hint {
    font-family:'DM Mono', monospace; font-size:8px;
    letter-spacing:4px; text-transform:uppercase;
    color:rgba(126,200,227,0.25);
    animation:breathe 3s ease-in-out infinite;
  }
  @keyframes breathe { 0%,100%{opacity:.25} 50%{opacity:.7} }

  /* Tooltip */
  #tip {
    position:fixed; z-index:200; pointer-events:none;
    padding:7px 14px;
    border:1px solid var(--border);
    background:rgba(6,13,20,0.88);
    backdrop-filter:blur(16px);
    font-family:'DM Mono', monospace; font-size:10px;
    letter-spacing:2px; color:var(--frost);
    text-transform:uppercase; opacity:0;
    transition:opacity .2s; white-space:nowrap;
  }

  @keyframes fadeUp  { from{opacity:0;transform:translateY(14px)} to{opacity:1;transform:translateY(0)} }
  @keyframes fadeIn  { from{opacity:0} to{opacity:1} }
  @keyframes slideIn { to{opacity:1;transform:translateX(0)} }
</style>
</head>
<body>

<div id="cur"></div>
<div id="cur-ring"></div>
<div id="vig"></div>
<div id="scan"></div>
<div id="tip"></div>

<div id="ui">
  <div class="hd">
    <div>
      <div class="logo">SYNAPSE</div>
      <div class="logo-tag">// Réseau Neuronal Vivant — Arctic Edition</div>
    </div>
    <div class="hd-right">
      <div class="neural-status">
        <div class="pulse-dot"></div>
        <div class="status-txt">Réseau Actif</div>
      </div>
      <div class="node-count" id="nodeCount">000 Neurones · 000 Connexions</div>
    </div>
  </div>

  <div class="center">
    <div class="eyebrow">// Intelligence artificielle — v3.1</div>
    <h1 class="hl">L'esprit<br>numérique<br><span>s'éveille</span></h1>
    <div class="sep"></div>
    <p class="body">Chaque nœud pulse,<br>chaque connexion transmet.<br>Observez la pensée prendre forme.</p>
    <div class="btns" style="margin-top:26px">
      <button class="btn-ice">Explorer</button>
      <button class="btn-line">Analyser</button>
    </div>
  </div>

  <div class="panel">
    <div class="metric">
      <div class="m-label">Neurones actifs</div>
      <div class="m-val" id="m1">—</div>
      <div class="m-bar"><div class="m-fill" style="--w:82%"></div></div>
    </div>
    <div class="metric">
      <div class="m-label">Bande passante</div>
      <div class="m-val" id="m2">—</div>
      <div class="m-bar"><div class="m-fill" style="--w:67%"></div></div>
    </div>
    <div class="metric">
      <div class="m-label">Précision</div>
      <div class="m-val" id="m3">—</div>
      <div class="m-bar"><div class="m-fill" style="--w:94%"></div></div>
    </div>
    <div class="metric">
      <div class="m-label">Latence</div>
      <div class="m-val" id="m4">—</div>
      <div class="m-bar"><div class="m-fill" style="--w:38%"></div></div>
    </div>
  </div>

  <div class="ft">
    <div class="stats">
      <div class="s"><div class="s-n">1<em>B</em></div><div class="s-l">Paramètres</div></div>
      <div class="s"><div class="s-n">99<em>%</em></div><div class="s-l">Uptime</div></div>
      <div class="s"><div class="s-n">4<em>ms</em></div><div class="s-l">Latence moy.</div></div>
    </div>
    <div class="hint">Cliquez · survolez les neurones</div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ═══════════════════════════════════
// SETUP
// ═══════════════════════════════════
const W = innerWidth, H = innerHeight;
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(W, H);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x060d14);
scene.fog = new THREE.FogExp2(0x060d14, 0.028);

const camera = new THREE.PerspectiveCamera(58, W / H, 0.1, 300);
camera.position.set(0, 0, 28);

// ═══════════════════════════════════
// MOUSE
// ═══════════════════════════════════
const mouse = { x: 0, y: 0 };
const curEl  = document.getElementById('cur');
const ringEl = document.getElementById('cur-ring');
const tipEl  = document.getElementById('tip');

document.addEventListener('mousemove', e => {
  mouse.x = (e.clientX / W) * 2 - 1;
  mouse.y = -(e.clientY / H) * 2 + 1;
  curEl.style.left  = e.clientX + 'px';
  curEl.style.top   = e.clientY + 'px';
  ringEl.style.left = e.clientX + 'px';
  ringEl.style.top  = e.clientY + 'px';
  tipEl.style.left  = (e.clientX + 20) + 'px';
  tipEl.style.top   = (e.clientY - 12) + 'px';
});

// ═══════════════════════════════════
// NEURAL NODES
// ═══════════════════════════════════
const NODE_COUNT = 120;
const nodes = [];
const nodeGroup = new THREE.Group();
scene.add(nodeGroup);

// Layer structure for a real neural look
const layers = [
  { count: 8,  x: -14, spread: 5 },
  { count: 16, x: -8,  spread: 7 },
  { count: 24, x: -2,  spread: 8 },
  { count: 24, x:  4,  spread: 8 },
  { count: 16, x: 10,  spread: 7 },
  { count: 8,  x: 16,  spread: 5 },
];

const nodeColors = [
  new THREE.Color(0xf0faff),
  new THREE.Color(0x7ec8e3),
  new THREE.Color(0xb8d4f0),
  new THREE.Color(0x3a8fb5),
  new THREE.Color(0xe8f4ff),
];

layers.forEach((layer, li) => {
  for (let i = 0; i < layer.count; i++) {
    const geo = new THREE.SphereGeometry(0.12 + Math.random() * 0.18, 16, 16);
    const col = nodeColors[Math.floor(Math.random() * nodeColors.length)];
    const mat = new THREE.MeshStandardMaterial({
      color: col,
      emissive: col,
      emissiveIntensity: 0.4,
      metalness: 0.1,
      roughness: 0.2,
      transparent: true,
      opacity: 0.85,
    });
    const mesh = new THREE.Mesh(geo, mat);

    const angle = (i / layer.count) * Math.PI * 2;
    const r = (Math.random() * 0.5 + 0.5) * layer.spread;
    mesh.position.set(
      layer.x + (Math.random() - 0.5) * 1.5,
      Math.cos(angle) * r,
      Math.sin(angle) * r
    );

    mesh.userData = {
      basePos:   mesh.position.clone(),
      layer:     li,
      pulse:     Math.random() * Math.PI * 2,
      pulseSpd:  0.5 + Math.random() * 1.5,
      active:    false,
      fireTimer: 0,
      col:       col.clone(),
      connections: [],
    };

    nodeGroup.add(mesh);
    nodes.push(mesh);
  }
});

document.getElementById('nodeCount').textContent =
  `${NODE_COUNT} Neurones · — Connexions`;

// ═══════════════════════════════════
// CONNECTIONS (SYNAPSES)
// ═══════════════════════════════════
const connGroup = new THREE.Group();
scene.add(connGroup);

const connections = [];

// Connect adjacent layers + some skip connections
nodes.forEach((n, i) => {
  const li = n.userData.layer;
  const targets = nodes.filter(m => {
    const diff = m.userData.layer - li;
    return diff === 1 || (diff === 2 && Math.random() < 0.08);
  });

  // Pick 1–4 targets
  const picks = targets
    .sort(() => Math.random() - 0.5)
    .slice(0, 1 + Math.floor(Math.random() * 3));

  picks.forEach(t => {
    const pts = [n.position, t.position];
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({
      color: 0x1a3d5c,
      transparent: true,
      opacity: 0.18,
    });
    const line = new THREE.Line(geo, mat);
    connGroup.add(line);

    const conn = { line, from: n, to: t, signal: null };
    connections.push(conn);
    n.userData.connections.push(conn);
  });
});

document.getElementById('nodeCount').textContent =
  `${nodes.length} Neurones · ${connections.length} Connexions`;

// ═══════════════════════════════════
// SIGNAL SPHERES (travelling pulses)
// ═══════════════════════════════════
const signals = [];
const signalPool = [];

function getSignal() {
  if (signalPool.length > 0) return signalPool.pop();
  const geo = new THREE.SphereGeometry(0.07, 8, 8);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xf0faff,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending,
  });
  const m = new THREE.Mesh(geo, mat);
  scene.add(m);
  return m;
}

function fireSignal(from, to, col) {
  const s = getSignal();
  s.position.copy(from.position);
  s.material.color.copy(col || new THREE.Color(0xf0faff));
  s.material.opacity = 0.9;
  s.visible = true;
  signals.push({ mesh: s, from, to, t: 0, speed: 0.6 + Math.random() * 0.8 });
}

// Randomly fire signals to simulate live neural activity
function randomFire() {
  const src = nodes[Math.floor(Math.random() * nodes.length)];
  src.userData.connections.forEach(c => {
    if (Math.random() < 0.35) {
      fireSignal(c.from, c.to, src.userData.col);
      c.line.material.opacity = 0.55;
      c.line.material.color.set(0x7ec8e3);
      setTimeout(() => {
        c.line.material.opacity = 0.18;
        c.line.material.color.set(0x1a3d5c);
      }, 400);
    }
  });
}

// Wave propagation from left to right
function propagateWave(layerIdx) {
  if (layerIdx >= layers.length) return;
  nodes.filter(n => n.userData.layer === layerIdx).forEach(n => {
    n.userData.active    = true;
    n.userData.fireTimer = 0.3 + Math.random() * 0.2;
    n.userData.connections.forEach(c => {
      if (c.to.userData.layer === layerIdx + 1) {
        setTimeout(() => fireSignal(c.from, c.to, n.userData.col), Math.random() * 200);
        c.line.material.opacity = 0.6;
        c.line.material.color.set(0xb8d4f0);
        setTimeout(() => {
          c.line.material.opacity = 0.18;
          c.line.material.color.set(0x1a3d5c);
        }, 500);
      }
    });
  });
  setTimeout(() => propagateWave(layerIdx + 1), 260);
}

// Kick off wave every 4s
function startWave() { propagateWave(0); }
startWave();
setInterval(startWave, 4000);

// Random ambient firing
setInterval(randomFire, 120);

// ═══════════════════════════════════
// AMBIENT PARTICLES
// ═══════════════════════════════════
const DUST = 1200;
const dPos = new Float32Array(DUST * 3);
const dVel = [];

for (let i = 0; i < DUST; i++) {
  const r = 5 + Math.random() * 22;
  const a = Math.random() * Math.PI * 2;
  const b = (Math.random() - 0.5) * Math.PI;
  dPos[i*3]   = r * Math.cos(b) * Math.cos(a);
  dPos[i*3+1] = r * Math.sin(b);
  dPos[i*3+2] = r * Math.cos(b) * Math.sin(a);
  dVel.push({
    x: (Math.random() - 0.5) * 0.005,
    y: (Math.random() - 0.5) * 0.005,
    z: (Math.random() - 0.5) * 0.005,
  });
}

const dGeo = new THREE.BufferGeometry();
dGeo.setAttribute('position', new THREE.BufferAttribute(dPos, 3));
const dMat = new THREE.PointsMaterial({
  size: 0.045, color: 0x7ec8e3, transparent: true, opacity: 0.4,
  blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true,
});
scene.add(new THREE.Points(dGeo, dMat));

// ═══════════════════════════════════
// LIGHTS
// ═══════════════════════════════════
scene.add(new THREE.AmbientLight(0x0d1f2d, 5));

const lA = new THREE.PointLight(0x7ec8e3, 4, 35);
lA.position.set(-10, 5, 5);
scene.add(lA);

const lB = new THREE.PointLight(0xb8d4f0, 3, 30);
lB.position.set(10, -3, -5);
scene.add(lB);

const lC = new THREE.PointLight(0xe8f4ff, 2, 20);
lC.position.set(0, 10, 10);
scene.add(lC);

// ═══════════════════════════════════
// RAYCASTER
// ═══════════════════════════════════
const ray = new THREE.Raycaster();
ray.params.Points.threshold = 0.3;
let hovered = null;
const nodeMeshes = nodes;

const nodeLabels = ['INPUT', 'HIDDEN', 'RELU', 'DROPOUT', 'SIGMOID', 'OUTPUT', 'DENSE'];

// ═══════════════════════════════════
// METRICS
// ═══════════════════════════════════
const metrics = [
  { id:'m1', val: 892,   fmt: v => `${Math.floor(v)}<span class="u"> K</span>` },
  { id:'m2', val: 48.3,  fmt: v => `${v.toFixed(1)}<span class="u"> GB</span>` },
  { id:'m3', val: 99.4,  fmt: v => `${v.toFixed(1)}<span class="u"> %</span>` },
  { id:'m4', val: 3.8,   fmt: v => `${v.toFixed(1)}<span class="u"> ms</span>` },
];
metrics.forEach((m, i) => {
  let cur = 0;
  const el = document.getElementById(m.id);
  setTimeout(() => {
    const step = () => {
      cur += m.val / 50;
      if (cur >= m.val) cur = m.val;
      el.innerHTML = m.fmt(cur);
      if (cur < m.val) requestAnimationFrame(step);
    };
    step();
  }, 700 + i * 180);
});
// Live fluctuation
setInterval(() => {
  metrics[2].val = Math.max(96, Math.min(99.9, metrics[2].val + (Math.random()-.48)*.3));
  metrics[3].val = Math.max(2, Math.min(8, metrics[3].val + (Math.random()-.45)*.2));
  document.getElementById('m3').innerHTML = metrics[2].fmt(metrics[2].val);
  document.getElementById('m4').innerHTML = metrics[3].fmt(metrics[3].val);
}, 1600);

// ═══════════════════════════════════
// SCROLL
// ═══════════════════════════════════
let zoomT = 28;
window.addEventListener('wheel', e => {
  zoomT += e.deltaY * 0.018;
  zoomT = Math.max(12, Math.min(45, zoomT));
});

// Click — trigger new wave
document.addEventListener('click', () => {
  propagateWave(0);
  // Brief white flash on all nodes
  nodes.forEach(n => {
    n.material.emissiveIntensity = 1.5;
    setTimeout(() => { n.material.emissiveIntensity = 0.4; }, 300);
  });
});

// ═══════════════════════════════════
// ANIMATE
// ═══════════════════════════════════
let t = 0;
const tmp = new THREE.Vector3();

function animate() {
  requestAnimationFrame(animate);
  t += 0.01;

  // Camera
  const cx = mouse.x * 5;
  const cy = mouse.y * 3;
  camera.position.x += (cx - camera.position.x) * 0.03;
  camera.position.y += (cy - camera.position.y) * 0.03;
  camera.position.z += (zoomT - camera.position.z) * 0.05;
  camera.lookAt(0, 0, 0);

  // Slow global rotation of the network
  nodeGroup.rotation.y = Math.sin(t * 0.08) * 0.25;
  connGroup.rotation.y = nodeGroup.rotation.y;

  // Node pulse
  nodes.forEach(n => {
    const { pulse, pulseSpd, active } = n.userData;
    const s = 1 + Math.sin(t * pulseSpd + pulse) * 0.08;
    n.scale.setScalar(s);

    if (active) {
      n.material.emissiveIntensity = 0.8 + Math.sin(t * 8 + pulse) * 0.4;
      n.userData.fireTimer -= 0.01;
      if (n.userData.fireTimer <= 0) n.userData.active = false;
    } else {
      n.material.emissiveIntensity = 0.25 + Math.sin(t * pulseSpd + pulse) * 0.15;
    }

    // Float subtly
    n.position.y = n.userData.basePos.y + Math.sin(t * 0.3 + pulse) * 0.12;
  });

  // Update connection lines to follow floating nodes
  connections.forEach(c => {
    const pts = c.line.geometry.attributes.position;
    pts.setXYZ(0, c.from.position.x, c.from.position.y, c.from.position.z);
    pts.setXYZ(1, c.to.position.x,   c.to.position.y,   c.to.position.z);
    pts.needsUpdate = true;
  });

  // Advance signals
  for (let i = signals.length - 1; i >= 0; i--) {
    const s = signals[i];
    s.t += s.speed * 0.016;
    if (s.t >= 1) {
      // Arrive — light up destination node briefly
      s.to.userData.active    = true;
      s.to.userData.fireTimer = 0.25;
      s.mesh.visible = false;
      signalPool.push(s.mesh);
      signals.splice(i, 1);
    } else {
      tmp.lerpVectors(s.from.position, s.to.position, s.t);
      s.mesh.position.copy(tmp);
      // Apply group rotation offset
      s.mesh.position.applyEuler(new THREE.Euler(0, nodeGroup.rotation.y, 0));
      s.mesh.material.opacity = 0.9 * Math.sin(s.t * Math.PI);
    }
  }

  // Dust drift
  const dp = dGeo.attributes.position.array;
  for (let i = 0; i < DUST; i++) {
    dp[i*3]   += dVel[i].x;
    dp[i*3+1] += dVel[i].y;
    dp[i*3+2] += dVel[i].z;
    const dist = Math.sqrt(dp[i*3]**2 + dp[i*3+1]**2 + dp[i*3+2]**2);
    if (dist > 26) {
      dp[i*3] *= 0.3; dp[i*3+1] *= 0.3; dp[i*3+2] *= 0.3;
    }
  }
  dGeo.attributes.position.needsUpdate = true;

  // Lights orbit
  lA.position.set(
    Math.cos(t * 0.3) * 14,
    5 + Math.sin(t * 0.2) * 3,
    Math.sin(t * 0.3) * 10
  );
  lB.position.set(
    Math.cos(t * 0.25 + 2) * 12,
    -3 + Math.cos(t * 0.18) * 4,
    Math.sin(t * 0.25 + 2) * 10
  );
  lA.intensity = 4 + Math.sin(t * 1.8) * 0.8;
  lB.intensity = 3 + Math.cos(t * 2.1) * 0.6;

  // Raycaster hover
  ray.setFromCamera({ x: mouse.x, y: mouse.y }, camera);
  const hits = ray.intersectObjects(nodeMeshes);
  if (hits.length > 0) {
    const obj = hits[0].object;
    if (hovered !== obj) {
      if (hovered) hovered.material.emissiveIntensity = 0.4;
      hovered = obj;
      hovered.material.emissiveIntensity = 2.0;
      const layer = layers[hovered.userData.layer];
      const lname = ['Entrée','Caché-1','Caché-2','Caché-3','Caché-4','Sortie'][hovered.userData.layer] || 'Couche';
      tipEl.textContent = `${lname}  ·  ${nodeLabels[hovered.userData.layer % nodeLabels.length]}`;
      tipEl.style.opacity = '1';
    }
    ringEl.classList.add('active');
  } else {
    if (hovered) { hovered.material.emissiveIntensity = 0.4; hovered = null; tipEl.style.opacity = '0'; }
    ringEl.classList.remove('active');
  }

  renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', () => {
  const w = innerWidth, h = innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});
</script>
</body>
</html>
