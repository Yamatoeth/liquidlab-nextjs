<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vortex — FORMA</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #020208; overflow: hidden; width: 100vw; height: 100vh; cursor: none; }
  canvas { display: block; }
  .label { position: fixed; bottom: 24px; left: 24px; font-family: 'Courier New', monospace; font-size: 11px; letter-spacing: 0.15em; color: rgba(255,255,255,0.2); text-transform: uppercase; pointer-events: none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="label">Vortex · Move cursor</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; cx = W/2; cy = H/2; }
resize();
window.addEventListener('resize', resize);

const mouse = { x: 0, y: 0 };
const smoothMouse = { x: 0, y: 0 };
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('touchmove', e => { mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; }, { passive: true });

// Particles in spiral
const N = 800;
let particles = [];

function initParticles() {
  particles = Array.from({ length: N }, (_, i) => {
    const angle = (i / N) * Math.PI * 2 * 8;
    const radius = 20 + (i / N) * Math.min(W, H) * 0.45;
    return {
      angle,
      radius,
      baseRadius: radius,
      speed: 0.002 + (1 - i/N) * 0.006,
      size: 0.5 + (1 - i/N) * 2,
      hue: 220 + (i/N) * 80,
      sat: 60 + (i/N) * 30,
      life: i / N,
    };
  });
}
initParticles();
window.addEventListener('resize', initParticles);

let time = 0;

function draw() {
  time += 0.008;

  smoothMouse.x += (mouse.x - smoothMouse.x) * 0.05;
  smoothMouse.y += (mouse.y - smoothMouse.y) * 0.05;

  // Center attraction offset from mouse
  const ox = (smoothMouse.x - W/2) * 0.08;
  const oy = (smoothMouse.y - H/2) * 0.08;
  const vcx = cx + ox;
  const vcy = cy + oy;

  ctx.fillStyle = 'rgba(2,2,8,0.18)';
  ctx.fillRect(0, 0, W, H);

  // Black hole core
  const coreGrad = ctx.createRadialGradient(vcx, vcy, 0, vcx, vcy, 80);
  coreGrad.addColorStop(0, 'rgba(0,0,0,1)');
  coreGrad.addColorStop(0.5, 'rgba(10,5,30,0.8)');
  coreGrad.addColorStop(1, 'rgba(2,2,8,0)');
  ctx.fillStyle = coreGrad;
  ctx.beginPath(); ctx.arc(vcx, vcy, 80, 0, Math.PI*2); ctx.fill();

  // Accretion ring glow
  const ringGrad = ctx.createRadialGradient(vcx, vcy, 50, vcx, vcy, 100);
  ringGrad.addColorStop(0, 'rgba(100,60,255,0)');
  ringGrad.addColorStop(0.5, `rgba(120,80,255,${0.12 + Math.sin(time*2)*0.04})`);
  ringGrad.addColorStop(1, 'rgba(100,60,255,0)');
  ctx.fillStyle = ringGrad;
  ctx.beginPath(); ctx.arc(vcx, vcy, 100, 0, Math.PI*2); ctx.fill();

  // Draw particles
  particles.forEach((p, i) => {
    // Pull toward center
    const distFromCenter = p.radius;
    const pull = 0.003 * (1 + (1 - distFromCenter / (Math.min(W,H)*0.45)) * 3);
    p.radius -= pull * distFromCenter * 0.01;
    p.angle += p.speed * (1 + 40 / (p.radius + 10));

    // Reset when too close
    if (p.radius < 15) {
      p.radius = p.baseRadius;
      p.angle = Math.random() * Math.PI * 2;
    }

    const x = vcx + Math.cos(p.angle) * p.radius;
    const y = vcy + Math.sin(p.angle) * p.radius * 0.4; // flatten for disc effect

    const alpha = Math.min(1, p.radius / 60) * 0.8;
    const bright = 50 + (1 - p.radius / (Math.min(W,H)*0.45)) * 40;

    ctx.beginPath();
    ctx.arc(x, y, p.size * (60 / (p.radius + 40)), 0, Math.PI*2);
    ctx.fillStyle = `hsla(${p.hue + time * 20},${p.sat}%,${bright}%,${alpha})`;
    ctx.fill();
  });

  // Lens flare
  const flareAlpha = 0.04 + Math.sin(time*3)*0.02;
  const flareGrad = ctx.createRadialGradient(vcx - 20, vcy - 20, 0, vcx, vcy, 30);
  flareGrad.addColorStop(0, `rgba(255,240,200,${flareAlpha})`);
  flareGrad.addColorStop(1, 'rgba(255,240,200,0)');
  ctx.fillStyle = flareGrad;
  ctx.beginPath(); ctx.arc(vcx, vcy, 30, 0, Math.PI*2); ctx.fill();

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
